package public

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"html/template"
	"io"
	"net/http"
	"path"
	"time"

	"github.com/navidrome/navidrome/conf"
	"github.com/navidrome/navidrome/consts"
	"github.com/navidrome/navidrome/core/auth"
	"github.com/navidrome/navidrome/core/publicurl"
	"github.com/navidrome/navidrome/log"
	"github.com/navidrome/navidrome/model"
	"github.com/navidrome/navidrome/resources"
	"github.com/navidrome/navidrome/server"
	"github.com/navidrome/navidrome/ui"
	. "github.com/navidrome/navidrome/utils/gg"
	"github.com/navidrome/navidrome/utils/req"
	"github.com/navidrome/navidrome/utils/slice"
	"github.com/navidrome/navidrome/utils/str"
)

func (pub *Router) handleShares(w http.ResponseWriter, r *http.Request) {
	id, err := req.Params(r).String(":id")
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// If requested file is a UI asset, just serve it
	_, err = ui.BuildAssets().Open(id)
	if err == nil {
		pub.assetsHandler.ServeHTTP(w, r)
		return
	}

	// If it is not, consider it a share ID
	s, err := pub.share.Load(r.Context(), id)
	if err != nil {
		checkShareError(r.Context(), w, err, id)
		return
	}

	s = pub.mapShareInfo(r, *s)
	server.IndexWithShare(pub.ds, ui.BuildAssets(), s)(w, r)
}

func (pub *Router) handleM3U(w http.ResponseWriter, r *http.Request) {
	id, err := req.Params(r).String(":id")
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// If it is not, consider it a share ID
	s, err := pub.share.Load(r.Context(), id)
	if err != nil {
		checkShareError(r.Context(), w, err, id)
		return
	}

	s = pub.mapShareToM3U(r, *s)
	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "audio/x-mpegurl")
	_, _ = w.Write([]byte(s.ToM3U8()))
}

func (pub *Router) handleAPlayer(w http.ResponseWriter, r *http.Request) {
	id, err := req.Params(r).String(":id")
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Load share
	s, err := pub.share.Load(r.Context(), id)
	if err != nil {
		checkShareError(r.Context(), w, err, id)
		return
	}

	// Map share info for APlayer
	s = pub.mapShareInfo(r, *s)

	// Read template
	tmplData, err := resources.FS().Open("aplayer.html")
	if err != nil {
		log.Error(r.Context(), "Could not find aplayer.html template", err)
		http.Error(w, "Template not found", http.StatusInternalServerError)
		return
	}
	defer tmplData.Close()

	tmplContent, err := io.ReadAll(tmplData)
	if err != nil {
		log.Error(r.Context(), "Error reading aplayer.html template", err)
		http.Error(w, "Error reading template", http.StatusInternalServerError)
		return
	}

	// Read APlayer script
	scriptData, err := resources.FS().Open("aplayer-share.js")
	if err != nil {
		log.Error(r.Context(), "Could not find aplayer-share.js", err)
		http.Error(w, "Script not found", http.StatusInternalServerError)
		return
	}
	defer scriptData.Close()

	scriptContent, err := io.ReadAll(scriptData)
	if err != nil {
		log.Error(r.Context(), "Error reading aplayer-share.js", err)
		http.Error(w, "Error reading script", http.StatusInternalServerError)
		return
	}

	// Parse template
	tmpl, err := template.New("aplayer").Parse(string(tmplContent))
	if err != nil {
		log.Error(r.Context(), "Error parsing aplayer.html template", err)
		http.Error(w, "Error parsing template", http.StatusInternalServerError)
		return
	}

	// Prepare share data for JSON
	type aplayerTrack struct {
		ID        string    `json:"id"`
		Title     string    `json:"title"`
		Artist    string    `json:"artist"`
		Album     string    `json:"album"`
		Duration  float32   `json:"duration"`
		UpdatedAt time.Time `json:"updatedAt"`
	}

	type aplayerShareInfo struct {
		ID           string         `json:"id"`
		Description  string         `json:"description"`
		Downloadable bool           `json:"downloadable"`
		Tracks       []aplayerTrack `json:"tracks"`
		ImageUrl     string         `json:"imageUrl"`
	}

	shareData := aplayerShareInfo{
		ID:           s.ID,
		Description:  s.Description,
		Downloadable: s.Downloadable,
		ImageUrl:     s.ImageURL,
		Tracks: slice.Map(s.Tracks, func(mf model.MediaFile) aplayerTrack {
			return aplayerTrack{
				ID:        mf.ID,
				Title:     mf.Title,
				Artist:    mf.Artist,
				Album:     mf.Album,
				Duration:  mf.Duration,
				UpdatedAt: mf.UpdatedAt,
			}
		}),
	}

	shareInfoJSON, err := json.Marshal(shareData)
	if err != nil {
		log.Error(r.Context(), "Error converting share data to JSON", err)
		http.Error(w, "Error processing share data", http.StatusInternalServerError)
		return
	}

	// Prepare template data
	description := s.Description
	if description == "" {
		description = str.SanitizeText(s.Contents)
	}
	if description == "" {
		description = "Shared Music"
	}

	baseURL := str.SanitizeText(conf.Server.BasePath)

	data := map[string]interface{}{
		"ShareDescription": description,
		// #nosec G203 -- shareInfoJSON is generated by json.Marshal from server data, not user input
		"ShareInfo": template.JS(shareInfoJSON),
		// #nosec G203 -- scriptContent is from embedded resource file, not user input
		"APlayerScript": template.JS(scriptContent),
		"BaseURL":       baseURL,
	}

	// Render template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Error(r.Context(), "Error executing aplayer template", err)
		http.Error(w, "Error rendering page", http.StatusInternalServerError)
		return
	}

	// Allow embedding in iframes for APlayer share pages
	w.Header().Set("X-Frame-Options", "ALLOWALL")
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	_, _ = w.Write(buf.Bytes())
}

func checkShareError(ctx context.Context, w http.ResponseWriter, err error, id string) {
	switch {
	case errors.Is(err, model.ErrExpired):
		log.Error(ctx, "Share expired", "id", id, err)
		http.Error(w, "Share not available anymore", http.StatusGone)
	case errors.Is(err, model.ErrNotFound):
		log.Error(ctx, "Share not found", "id", id, err)
		http.Error(w, "Share not found", http.StatusNotFound)
	case errors.Is(err, model.ErrNotAuthorized):
		log.Error(ctx, "Share is not downloadable", "id", id, err)
		http.Error(w, "This share is not downloadable", http.StatusForbidden)
	case err != nil:
		log.Error(ctx, "Error retrieving share", "id", id, err)
		http.Error(w, "Error retrieving share", http.StatusInternalServerError)
	}
}

func (pub *Router) mapShareInfo(r *http.Request, s model.Share) *model.Share {
	s.URL = ShareURL(r, s.ID)
	s.ImageURL = publicurl.ImageURL(r, s.CoverArtID(), consts.UICoverArtSize)
	for i := range s.Tracks {
		s.Tracks[i].ID = encodeMediafileShare(s, s.Tracks[i].ID)
	}
	return &s
}

func (pub *Router) mapShareToM3U(r *http.Request, s model.Share) *model.Share {
	for i := range s.Tracks {
		id := encodeMediafileShare(s, s.Tracks[i].ID)
		s.Tracks[i].Path = publicurl.PublicURL(r, path.Join(consts.URLPathPublic, "s", id), nil)
	}
	return &s
}

func encodeMediafileShare(s model.Share, id string) string {
	claims := map[string]any{"id": id}
	if s.Format != "" {
		claims["f"] = s.Format
	}
	if s.MaxBitRate != 0 {
		claims["b"] = s.MaxBitRate
	}
	token, _ := auth.CreateExpiringPublicToken(V(s.ExpiresAt), claims)
	return token
}
