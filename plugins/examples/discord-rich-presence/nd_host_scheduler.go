// Code generated by hostgen. DO NOT EDIT.
//
// This file contains client wrappers for the Scheduler host service.
// It is intended for use in Navidrome plugins built with TinyGo.
//
//go:build wasip1

package main

import (
	"encoding/json"
	"errors"

	"github.com/extism/go-pdk"
)

// scheduler_scheduleonetime is the host function provided by Navidrome.
//
//go:wasmimport extism:host/user scheduler_scheduleonetime
func scheduler_scheduleonetime(uint64) uint64

// scheduler_schedulerecurring is the host function provided by Navidrome.
//
//go:wasmimport extism:host/user scheduler_schedulerecurring
func scheduler_schedulerecurring(uint64) uint64

// scheduler_cancelschedule is the host function provided by Navidrome.
//
//go:wasmimport extism:host/user scheduler_cancelschedule
func scheduler_cancelschedule(uint64) uint64

// SchedulerScheduleOneTimeRequest is the request type for Scheduler.ScheduleOneTime.
type SchedulerScheduleOneTimeRequest struct {
	DelaySeconds int32  `json:"delaySeconds"`
	Payload      string `json:"payload"`
	ScheduleID   string `json:"scheduleId"`
}

// SchedulerScheduleOneTimeResponse is the response type for Scheduler.ScheduleOneTime.
type SchedulerScheduleOneTimeResponse struct {
	NewScheduleID string `json:"newScheduleId,omitempty"`
	Error         string `json:"error,omitempty"`
}

// SchedulerScheduleRecurringRequest is the request type for Scheduler.ScheduleRecurring.
type SchedulerScheduleRecurringRequest struct {
	CronExpression string `json:"cronExpression"`
	Payload        string `json:"payload"`
	ScheduleID     string `json:"scheduleId"`
}

// SchedulerScheduleRecurringResponse is the response type for Scheduler.ScheduleRecurring.
type SchedulerScheduleRecurringResponse struct {
	NewScheduleID string `json:"newScheduleId,omitempty"`
	Error         string `json:"error,omitempty"`
}

// SchedulerCancelScheduleRequest is the request type for Scheduler.CancelSchedule.
type SchedulerCancelScheduleRequest struct {
	ScheduleID string `json:"scheduleId"`
}

// SchedulerCancelScheduleResponse is the response type for Scheduler.CancelSchedule.
type SchedulerCancelScheduleResponse struct {
	Error string `json:"error,omitempty"`
}

// SchedulerScheduleOneTime calls the scheduler_scheduleonetime host function.
// ScheduleOneTime schedules a one-time event to be triggered after the specified delay.
// Plugins that use this function must also implement the SchedulerCallback capability
//
// Parameters:
//   - delaySeconds: Number of seconds to wait before triggering the event
//   - payload: Data to be passed to the scheduled event handler
//   - scheduleID: Optional unique identifier for the scheduled job. If empty, one will be generated
//
// Returns the schedule ID that can be used to cancel the job, or an error if scheduling fails.
func SchedulerScheduleOneTime(delaySeconds int32, payload string, scheduleID string) (*SchedulerScheduleOneTimeResponse, error) {
	// Marshal request to JSON
	req := SchedulerScheduleOneTimeRequest{
		DelaySeconds: delaySeconds,
		Payload:      payload,
		ScheduleID:   scheduleID,
	}
	reqBytes, err := json.Marshal(req)
	if err != nil {
		return nil, err
	}
	reqMem := pdk.AllocateBytes(reqBytes)
	defer reqMem.Free()

	// Call the host function
	responsePtr := scheduler_scheduleonetime(reqMem.Offset())

	// Read the response from memory
	responseMem := pdk.FindMemory(responsePtr)
	responseBytes := responseMem.ReadBytes()

	// Parse the response
	var response SchedulerScheduleOneTimeResponse
	if err := json.Unmarshal(responseBytes, &response); err != nil {
		return nil, err
	}

	// Convert Error field to Go error
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}

	return &response, nil
}

// SchedulerScheduleRecurring calls the scheduler_schedulerecurring host function.
// ScheduleRecurring schedules a recurring event using a cron expression.
// Plugins that use this function must also implement the SchedulerCallback capability
//
// Parameters:
//   - cronExpression: Standard cron format expression (e.g., "0 0 * * *" for daily at midnight)
//   - payload: Data to be passed to each scheduled event handler invocation
//   - scheduleID: Optional unique identifier for the scheduled job. If empty, one will be generated
//
// Returns the schedule ID that can be used to cancel the job, or an error if scheduling fails.
func SchedulerScheduleRecurring(cronExpression string, payload string, scheduleID string) (*SchedulerScheduleRecurringResponse, error) {
	// Marshal request to JSON
	req := SchedulerScheduleRecurringRequest{
		CronExpression: cronExpression,
		Payload:        payload,
		ScheduleID:     scheduleID,
	}
	reqBytes, err := json.Marshal(req)
	if err != nil {
		return nil, err
	}
	reqMem := pdk.AllocateBytes(reqBytes)
	defer reqMem.Free()

	// Call the host function
	responsePtr := scheduler_schedulerecurring(reqMem.Offset())

	// Read the response from memory
	responseMem := pdk.FindMemory(responsePtr)
	responseBytes := responseMem.ReadBytes()

	// Parse the response
	var response SchedulerScheduleRecurringResponse
	if err := json.Unmarshal(responseBytes, &response); err != nil {
		return nil, err
	}

	// Convert Error field to Go error
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}

	return &response, nil
}

// SchedulerCancelSchedule calls the scheduler_cancelschedule host function.
// CancelSchedule cancels a scheduled job identified by its schedule ID.
//
// This works for both one-time and recurring schedules. Once cancelled, the job will not trigger
// any future events.
//
// Returns an error if the schedule ID is not found or if cancellation fails.
func SchedulerCancelSchedule(scheduleID string) (*SchedulerCancelScheduleResponse, error) {
	// Marshal request to JSON
	req := SchedulerCancelScheduleRequest{
		ScheduleID: scheduleID,
	}
	reqBytes, err := json.Marshal(req)
	if err != nil {
		return nil, err
	}
	reqMem := pdk.AllocateBytes(reqBytes)
	defer reqMem.Free()

	// Call the host function
	responsePtr := scheduler_cancelschedule(reqMem.Offset())

	// Read the response from memory
	responseMem := pdk.FindMemory(responsePtr)
	responseBytes := responseMem.ReadBytes()

	// Parse the response
	var response SchedulerCancelScheduleResponse
	if err := json.Unmarshal(responseBytes, &response); err != nil {
		return nil, err
	}

	// Convert Error field to Go error
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}

	return &response, nil
}
