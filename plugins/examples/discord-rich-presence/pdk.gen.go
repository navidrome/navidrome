// THIS FILE WAS GENERATED BY `xtp-go-bindgen`. DO NOT EDIT.
// Combined from: scrobbler.yaml, scheduler_callback.yaml, websocket_callback.yaml
package main

import (
	"errors"

	pdk "github.com/extism/go-pdk"
)

// ============================================================================
// Scrobbler Capability Functions
// ============================================================================

//export nd_scrobbler_is_authorized
func _NdScrobblerIsAuthorized() int32 {
	var input AuthInput
	if err := pdk.InputJSON(&input); err != nil {
		pdk.SetError(err)
		return -1
	}

	output, err := NdScrobblerIsAuthorized(input)
	if err != nil {
		pdk.SetError(err)
		return -1
	}

	if err := pdk.OutputJSON(output); err != nil {
		pdk.SetError(err)
		return -1
	}
	return 0
}

//export nd_scrobbler_now_playing
func _NdScrobblerNowPlaying() int32 {
	var input NowPlayingInput
	if err := pdk.InputJSON(&input); err != nil {
		pdk.SetError(err)
		return -1
	}

	output, err := NdScrobblerNowPlaying(input)
	if err != nil {
		pdk.SetError(err)
		return -1
	}

	if err := pdk.OutputJSON(output); err != nil {
		pdk.SetError(err)
		return -1
	}
	return 0
}

//export nd_scrobbler_scrobble
func _NdScrobblerScrobble() int32 {
	var input ScrobbleInput
	if err := pdk.InputJSON(&input); err != nil {
		pdk.SetError(err)
		return -1
	}

	output, err := NdScrobblerScrobble(input)
	if err != nil {
		pdk.SetError(err)
		return -1
	}

	if err := pdk.OutputJSON(output); err != nil {
		pdk.SetError(err)
		return -1
	}
	return 0
}

// ============================================================================
// Scheduler Callback Capability Functions
// ============================================================================

//export nd_scheduler_callback
func _NdSchedulerCallback() int32 {
	var input SchedulerCallbackInput
	if err := pdk.InputJSON(&input); err != nil {
		pdk.SetError(err)
		return -1
	}

	output, err := NdSchedulerCallback(input)
	if err != nil {
		pdk.SetError(err)
		return -1
	}

	if err := pdk.OutputJSON(output); err != nil {
		pdk.SetError(err)
		return -1
	}
	return 0
}

// ============================================================================
// WebSocket Callback Capability Functions
// ============================================================================

//export nd_websocket_on_text_message
func _NdWebsocketOnTextMessage() int32 {
	var input OnTextMessageInput
	if err := pdk.InputJSON(&input); err != nil {
		pdk.SetError(err)
		return -1
	}

	output, err := NdWebsocketOnTextMessage(input)
	if err != nil {
		pdk.SetError(err)
		return -1
	}

	if err := pdk.OutputJSON(output); err != nil {
		pdk.SetError(err)
		return -1
	}
	return 0
}

//export nd_websocket_on_binary_message
func _NdWebsocketOnBinaryMessage() int32 {
	var input OnBinaryMessageInput
	if err := pdk.InputJSON(&input); err != nil {
		pdk.SetError(err)
		return -1
	}

	output, err := NdWebsocketOnBinaryMessage(input)
	if err != nil {
		pdk.SetError(err)
		return -1
	}

	if err := pdk.OutputJSON(output); err != nil {
		pdk.SetError(err)
		return -1
	}
	return 0
}

//export nd_websocket_on_error
func _NdWebsocketOnError() int32 {
	var input OnErrorInput
	if err := pdk.InputJSON(&input); err != nil {
		pdk.SetError(err)
		return -1
	}

	output, err := NdWebsocketOnError(input)
	if err != nil {
		pdk.SetError(err)
		return -1
	}

	if err := pdk.OutputJSON(output); err != nil {
		pdk.SetError(err)
		return -1
	}
	return 0
}

//export nd_websocket_on_close
func _NdWebsocketOnClose() int32 {
	var input OnCloseInput
	if err := pdk.InputJSON(&input); err != nil {
		pdk.SetError(err)
		return -1
	}

	output, err := NdWebsocketOnClose(input)
	if err != nil {
		pdk.SetError(err)
		return -1
	}

	if err := pdk.OutputJSON(output); err != nil {
		pdk.SetError(err)
		return -1
	}
	return 0
}

// ============================================================================
// Scrobbler Types
// ============================================================================

// AuthInput is the input for authorization check
type AuthInput struct {
	// The internal Navidrome user ID
	UserId string `json:"user_id"`
	// The username of the user
	Username string `json:"username"`
}

// AuthOutput is the output for authorization check
type AuthOutput struct {
	// Whether the user is authorized to scrobble
	Authorized bool `json:"authorized"`
}

// NowPlayingInput is the input for now playing notification
type NowPlayingInput struct {
	// Current playback position in seconds
	Position int32 `json:"position"`
	// The track currently playing
	Track TrackInfo `json:"track"`
	// The internal Navidrome user ID
	UserId string `json:"user_id"`
	// The username of the user
	Username string `json:"username"`
}

// ScrobbleInput is the input for submitting a scrobble
type ScrobbleInput struct {
	// Unix timestamp when the track started playing
	Timestamp int64 `json:"timestamp"`
	// The track that was played
	Track TrackInfo `json:"track"`
	// The internal Navidrome user ID
	UserId string `json:"user_id"`
	// The username of the user
	Username string `json:"username"`
}

// ScrobblerErrorType indicates how Navidrome should handle the error
type ScrobblerErrorType string

const (
	ScrobblerErrorTypeNone          ScrobblerErrorType = "none"
	ScrobblerErrorTypeNotAuthorized ScrobblerErrorType = "not_authorized"
	ScrobblerErrorTypeRetryLater    ScrobblerErrorType = "retry_later"
	ScrobblerErrorTypeUnrecoverable ScrobblerErrorType = "unrecoverable"
)

func (v ScrobblerErrorType) String() string {
	switch v {
	case ScrobblerErrorTypeNone:
		return `none`
	case ScrobblerErrorTypeNotAuthorized:
		return `not_authorized`
	case ScrobblerErrorTypeRetryLater:
		return `retry_later`
	case ScrobblerErrorTypeUnrecoverable:
		return `unrecoverable`
	default:
		return ""
	}
}

func stringToScrobblerErrorType(s string) (ScrobblerErrorType, error) {
	switch s {
	case `none`:
		return ScrobblerErrorTypeNone, nil
	case `not_authorized`:
		return ScrobblerErrorTypeNotAuthorized, nil
	case `retry_later`:
		return ScrobblerErrorTypeRetryLater, nil
	case `unrecoverable`:
		return ScrobblerErrorTypeUnrecoverable, nil
	default:
		return ScrobblerErrorType(""), errors.New("unable to convert string to ScrobblerErrorType")
	}
}

// ScrobblerOutput is the output for scrobbler operations (now_playing and scrobble)
type ScrobblerOutput struct {
	// Error message if the operation failed
	Error *string `json:"error,omitempty"`
	// Type of error for handling
	ErrorType ScrobblerErrorType `json:"error_type,omitempty"`
}

// TrackInfo contains track metadata for scrobbling
type TrackInfo struct {
	// Album name
	Album string `json:"album"`
	// Album artist
	AlbumArtist string `json:"album_artist"`
	// Track artist
	Artist string `json:"artist"`
	// Disc number
	DiscNumber int32 `json:"disc_number"`
	// Track duration in seconds
	Duration float32 `json:"duration"`
	// The internal Navidrome track ID
	Id string `json:"id"`
	// MusicBrainz album artist ID
	MbzAlbumArtistId *string `json:"mbz_album_artist_id,omitempty"`
	// MusicBrainz album/release ID
	MbzAlbumId *string `json:"mbz_album_id,omitempty"`
	// MusicBrainz artist ID
	MbzArtistId *string `json:"mbz_artist_id,omitempty"`
	// MusicBrainz recording ID
	MbzRecordingId *string `json:"mbz_recording_id,omitempty"`
	// MusicBrainz release group ID
	MbzReleaseGroupId *string `json:"mbz_release_group_id,omitempty"`
	// MusicBrainz release track ID
	MbzReleaseTrackId *string `json:"mbz_release_track_id,omitempty"`
	// Track title
	Title string `json:"title"`
	// Track number on the album
	TrackNumber int32 `json:"track_number"`
}

// ============================================================================
// Scheduler Callback Types
// ============================================================================

// SchedulerCallbackInput is provided when a scheduled task fires
type SchedulerCallbackInput struct {
	// True if this is a recurring schedule (created via ScheduleRecurring),
	// false if it's a one-time schedule (created via ScheduleOneTime).
	IsRecurring bool `json:"is_recurring"`
	// The payload data that was provided when the task was scheduled.
	// Can be used to pass context or parameters to the callback handler.
	Payload string `json:"payload"`
	// The unique identifier for this scheduled task. This is either the ID
	// provided when scheduling, or an auto-generated UUID if none was specified.
	ScheduleId string `json:"schedule_id"`
}

// SchedulerCallbackOutput is the output from the scheduler callback
type SchedulerCallbackOutput struct {
	// Error message if the callback failed to process the scheduled task.
	// Empty or null indicates success. The error is logged but does not
	// affect the scheduling system.
	Error *string `json:"error,omitempty"`
}

// ============================================================================
// WebSocket Callback Types
// ============================================================================

// OnTextMessageInput is provided when a text message is received
type OnTextMessageInput struct {
	// The unique identifier for the WebSocket connection that received the message.
	ConnectionId string `json:"connection_id"`
	// The text message content received from the WebSocket.
	Message string `json:"message"`
}

// OnTextMessageOutput is the output from the text message handler
type OnTextMessageOutput struct {
	// Error message if the callback failed. Empty or null indicates success.
	Error *string `json:"error,omitempty"`
}

// OnBinaryMessageInput is provided when a binary message is received
type OnBinaryMessageInput struct {
	// The unique identifier for the WebSocket connection that received the message.
	ConnectionId string `json:"connection_id"`
	// The binary data received from the WebSocket, encoded as base64.
	Data string `json:"data"`
}

// OnBinaryMessageOutput is the output from the binary message handler
type OnBinaryMessageOutput struct {
	// Error message if the callback failed. Empty or null indicates success.
	Error *string `json:"error,omitempty"`
}

// OnErrorInput is provided when an error occurs on a WebSocket connection
type OnErrorInput struct {
	// The unique identifier for the WebSocket connection where the error occurred.
	ConnectionId string `json:"connection_id"`
	// The error message describing what went wrong.
	Error string `json:"error"`
}

// OnErrorOutput is the output from the error handler
type OnErrorOutput struct {
	// Error message if the callback failed. Empty or null indicates success.
	Error *string `json:"error,omitempty"`
}

// OnCloseInput is provided when a WebSocket connection is closed
type OnCloseInput struct {
	// The WebSocket close status code (e.g., 1000 for normal closure,
	// 1001 for going away, 1006 for abnormal closure).
	Code int32 `json:"code"`
	// The unique identifier for the WebSocket connection that was closed.
	ConnectionId string `json:"connection_id"`
	// The human-readable reason for the connection closure, if provided.
	Reason string `json:"reason"`
}

// OnCloseOutput is the output from the close handler
type OnCloseOutput struct {
	// Error message if the callback failed. Empty or null indicates success.
	Error *string `json:"error,omitempty"`
}
