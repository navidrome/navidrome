// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package plugins

import "encoding/json"
import "fmt"

// Configuration access permissions for a plugin
type ConfigPermission struct {
	// Explanation for why config access is needed
	Reason *string `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`
}

// HTTP access permissions for a plugin
type HTTPPermission struct {
	// List of allowed host patterns for HTTP requests (e.g., 'api.example.com',
	// '*.spotify.com')
	AllowedHosts []string `json:"allowedHosts,omitempty" yaml:"allowedHosts,omitempty" mapstructure:"allowedHosts,omitempty"`

	// Explanation for why HTTP access is needed
	Reason *string `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`
}

// Plugin manifest for Navidrome plugins
type Manifest struct {
	// The author of the plugin
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// A brief description of what the plugin does
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The display name of the plugin
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Permissions corresponds to the JSON schema field "permissions".
	Permissions *Permissions `json:"permissions,omitempty" yaml:"permissions,omitempty" mapstructure:"permissions,omitempty"`

	// The version of the plugin (semver recommended)
	Version string `json:"version" yaml:"version" mapstructure:"version"`

	// URL to the plugin's website or repository
	Website *string `json:"website,omitempty" yaml:"website,omitempty" mapstructure:"website,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Manifest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in Manifest: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Manifest: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in Manifest: required")
	}
	type Plain Manifest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Author) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "author", 1)
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Version) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "version", 1)
	}
	*j = Manifest(plain)
	return nil
}

// Permissions required by the plugin
type Permissions struct {
	// Config corresponds to the JSON schema field "config".
	Config *ConfigPermission `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Http corresponds to the JSON schema field "http".
	Http *HTTPPermission `json:"http,omitempty" yaml:"http,omitempty" mapstructure:"http,omitempty"`

	// Subsonicapi corresponds to the JSON schema field "subsonicapi".
	Subsonicapi *SubsonicAPIPermission `json:"subsonicapi,omitempty" yaml:"subsonicapi,omitempty" mapstructure:"subsonicapi,omitempty"`
}

// SubsonicAPI service permissions
type SubsonicAPIPermission struct {
	// If false, reject calls where the u is an admin
	AllowAdmins bool `json:"allowAdmins,omitempty" yaml:"allowAdmins,omitempty" mapstructure:"allowAdmins,omitempty"`

	// List of usernames the plugin can pass as u. Any user if empty
	AllowedUsernames []string `json:"allowedUsernames,omitempty" yaml:"allowedUsernames,omitempty" mapstructure:"allowedUsernames,omitempty"`

	// Explanation for why SubsonicAPI access is needed
	Reason *string `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubsonicAPIPermission) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain SubsonicAPIPermission
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["allowAdmins"]; !ok || v == nil {
		plain.AllowAdmins = false
	}
	*j = SubsonicAPIPermission(plain)
	return nil
}
