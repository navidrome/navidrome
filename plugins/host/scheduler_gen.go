// Code generated by hostgen. DO NOT EDIT.

package host

import (
	"context"
	"encoding/json"

	extism "github.com/extism/go-sdk"
)

// SchedulerScheduleOneTimeResponse is the response type for Scheduler.ScheduleOneTime.
type SchedulerScheduleOneTimeResponse struct {
	NewScheduleID string `json:"newScheduleID,omitempty"`
	Error         string `json:"error,omitempty"`
}

// SchedulerScheduleRecurringResponse is the response type for Scheduler.ScheduleRecurring.
type SchedulerScheduleRecurringResponse struct {
	NewScheduleID string `json:"newScheduleID,omitempty"`
	Error         string `json:"error,omitempty"`
}

// RegisterSchedulerHostFunctions registers Scheduler service host functions.
// The returned host functions should be added to the plugin's configuration.
func RegisterSchedulerHostFunctions(service SchedulerService) []extism.HostFunction {
	return []extism.HostFunction{
		newSchedulerScheduleOneTimeHostFunction(service),
		newSchedulerScheduleRecurringHostFunction(service),
		newSchedulerCancelScheduleHostFunction(service),
	}
}

func newSchedulerScheduleOneTimeHostFunction(service SchedulerService) extism.HostFunction {
	return extism.NewHostFunctionWithStack(
		"scheduler_scheduleonetime",
		func(ctx context.Context, p *extism.CurrentPlugin, stack []uint64) {
			// Read parameters from stack
			delaySeconds := extism.DecodeI32(stack[0])
			payload, err := p.ReadString(stack[1])
			if err != nil {
				return
			}
			scheduleID, err := p.ReadString(stack[2])
			if err != nil {
				return
			}

			// Call the service method
			newscheduleid, err := service.ScheduleOneTime(ctx, delaySeconds, payload, scheduleID)
			if err != nil {
				schedulerWriteError(p, stack, err)
				return
			}
			// Write JSON response to plugin memory
			resp := SchedulerScheduleOneTimeResponse{
				NewScheduleID: newscheduleid,
			}
			schedulerWriteResponse(p, stack, resp)
		},
		[]extism.ValueType{extism.ValueTypeI32, extism.ValueTypePTR, extism.ValueTypePTR},
		[]extism.ValueType{extism.ValueTypePTR},
	)
}

func newSchedulerScheduleRecurringHostFunction(service SchedulerService) extism.HostFunction {
	return extism.NewHostFunctionWithStack(
		"scheduler_schedulerecurring",
		func(ctx context.Context, p *extism.CurrentPlugin, stack []uint64) {
			// Read parameters from stack
			cronExpression, err := p.ReadString(stack[0])
			if err != nil {
				return
			}
			payload, err := p.ReadString(stack[1])
			if err != nil {
				return
			}
			scheduleID, err := p.ReadString(stack[2])
			if err != nil {
				return
			}

			// Call the service method
			newscheduleid, err := service.ScheduleRecurring(ctx, cronExpression, payload, scheduleID)
			if err != nil {
				schedulerWriteError(p, stack, err)
				return
			}
			// Write JSON response to plugin memory
			resp := SchedulerScheduleRecurringResponse{
				NewScheduleID: newscheduleid,
			}
			schedulerWriteResponse(p, stack, resp)
		},
		[]extism.ValueType{extism.ValueTypePTR, extism.ValueTypePTR, extism.ValueTypePTR},
		[]extism.ValueType{extism.ValueTypePTR},
	)
}

func newSchedulerCancelScheduleHostFunction(service SchedulerService) extism.HostFunction {
	return extism.NewHostFunctionWithStack(
		"scheduler_cancelschedule",
		func(ctx context.Context, p *extism.CurrentPlugin, stack []uint64) {
			// Read parameters from stack
			scheduleID, err := p.ReadString(stack[0])
			if err != nil {
				return
			}

			// Call the service method
			err = service.CancelSchedule(ctx, scheduleID)
			if err != nil {
				// Write error string to plugin memory
				if ptr, err := p.WriteString(err.Error()); err == nil {
					stack[0] = ptr
				}
				return
			}
			// Write empty string to indicate success
			if ptr, err := p.WriteString(""); err == nil {
				stack[0] = ptr
			}
		},
		[]extism.ValueType{extism.ValueTypePTR},
		[]extism.ValueType{extism.ValueTypePTR},
	)
}

// schedulerWriteResponse writes a JSON response to plugin memory.
func schedulerWriteResponse(p *extism.CurrentPlugin, stack []uint64, resp any) {
	respBytes, err := json.Marshal(resp)
	if err != nil {
		schedulerWriteError(p, stack, err)
		return
	}
	respPtr, err := p.WriteBytes(respBytes)
	if err != nil {
		stack[0] = 0
		return
	}
	stack[0] = respPtr
}

// schedulerWriteError writes an error response to plugin memory.
func schedulerWriteError(p *extism.CurrentPlugin, stack []uint64, err error) {
	errResp := struct {
		Error string `json:"error"`
	}{Error: err.Error()}
	respBytes, _ := json.Marshal(errResp)
	respPtr, _ := p.WriteBytes(respBytes)
	stack[0] = respPtr
}
