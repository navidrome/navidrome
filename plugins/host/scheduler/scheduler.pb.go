// Code generated by protoc-gen-go-plugin. DO NOT EDIT.
// versions:
// 	protoc-gen-go-plugin v0.1.0
// 	protoc               v5.29.3
// source: host/scheduler/scheduler.proto

package scheduler

import (
	context "context"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ScheduleOneTimeRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	DelaySeconds int32  `protobuf:"varint,1,opt,name=delay_seconds,json=delaySeconds,proto3" json:"delay_seconds,omitempty"` // Delay in seconds
	Payload      []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`                                // Serialized data to pass to the callback
	ScheduleId   string `protobuf:"bytes,3,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`        // Optional custom ID (if not provided, one will be generated)
}

func (x *ScheduleOneTimeRequest) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *ScheduleOneTimeRequest) GetDelaySeconds() int32 {
	if x != nil {
		return x.DelaySeconds
	}
	return 0
}

func (x *ScheduleOneTimeRequest) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ScheduleOneTimeRequest) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

type ScheduleRecurringRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CronExpression string `protobuf:"bytes,1,opt,name=cron_expression,json=cronExpression,proto3" json:"cron_expression,omitempty"` // Cron expression (e.g. "0 0 * * *" for daily at midnight)
	Payload        []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`                                     // Serialized data to pass to the callback
	ScheduleId     string `protobuf:"bytes,3,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`             // Optional custom ID (if not provided, one will be generated)
}

func (x *ScheduleRecurringRequest) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *ScheduleRecurringRequest) GetCronExpression() string {
	if x != nil {
		return x.CronExpression
	}
	return ""
}

func (x *ScheduleRecurringRequest) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ScheduleRecurringRequest) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

type ScheduleResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ScheduleId string `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"` // ID to reference this scheduled job
}

func (x *ScheduleResponse) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *ScheduleResponse) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

type CancelRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ScheduleId string `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"` // ID of the schedule to cancel
}

func (x *CancelRequest) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *CancelRequest) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

type CancelResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"` // Whether cancellation was successful
	Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`      // Error message if cancellation failed
}

func (x *CancelResponse) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *CancelResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *CancelResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type TimeNowRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *TimeNowRequest) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

type TimeNowResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Rfc3339Nano   string `protobuf:"bytes,1,opt,name=rfc3339_nano,json=rfc3339Nano,proto3" json:"rfc3339_nano,omitempty"`         // Current time in RFC3339Nano format
	UnixMilli     int64  `protobuf:"varint,2,opt,name=unix_milli,json=unixMilli,proto3" json:"unix_milli,omitempty"`              // Current time as Unix milliseconds timestamp
	LocalTimeZone string `protobuf:"bytes,3,opt,name=local_time_zone,json=localTimeZone,proto3" json:"local_time_zone,omitempty"` // Local timezone name (e.g., "America/New_York", "UTC")
}

func (x *TimeNowResponse) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *TimeNowResponse) GetRfc3339Nano() string {
	if x != nil {
		return x.Rfc3339Nano
	}
	return ""
}

func (x *TimeNowResponse) GetUnixMilli() int64 {
	if x != nil {
		return x.UnixMilli
	}
	return 0
}

func (x *TimeNowResponse) GetLocalTimeZone() string {
	if x != nil {
		return x.LocalTimeZone
	}
	return ""
}

// go:plugin type=host version=1
type SchedulerService interface {
	// One-time event scheduling
	ScheduleOneTime(context.Context, *ScheduleOneTimeRequest) (*ScheduleResponse, error)
	// Recurring event scheduling
	ScheduleRecurring(context.Context, *ScheduleRecurringRequest) (*ScheduleResponse, error)
	// Cancel any scheduled job
	CancelSchedule(context.Context, *CancelRequest) (*CancelResponse, error)
	// Get current time in multiple formats
	TimeNow(context.Context, *TimeNowRequest) (*TimeNowResponse, error)
}
