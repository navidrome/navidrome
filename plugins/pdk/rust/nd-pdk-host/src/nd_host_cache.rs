// Code generated by ndpgen. DO NOT EDIT.
//
// This file contains client wrappers for the Cache host service.
// It is intended for use in Navidrome plugins built with extism-pdk.

use extism_pdk::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheSetStringRequest {
    key: String,
    value: String,
    ttl_seconds: i64,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheSetStringResponse {
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheGetStringRequest {
    key: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheGetStringResponse {
    #[serde(default)]
    value: String,
    #[serde(default)]
    exists: bool,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheSetIntRequest {
    key: String,
    value: i64,
    ttl_seconds: i64,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheSetIntResponse {
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheGetIntRequest {
    key: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheGetIntResponse {
    #[serde(default)]
    value: i64,
    #[serde(default)]
    exists: bool,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheSetFloatRequest {
    key: String,
    value: f64,
    ttl_seconds: i64,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheSetFloatResponse {
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheGetFloatRequest {
    key: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheGetFloatResponse {
    #[serde(default)]
    value: f64,
    #[serde(default)]
    exists: bool,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheSetBytesRequest {
    key: String,
    value: Vec<u8>,
    ttl_seconds: i64,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheSetBytesResponse {
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheGetBytesRequest {
    key: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheGetBytesResponse {
    #[serde(default)]
    value: Vec<u8>,
    #[serde(default)]
    exists: bool,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheHasRequest {
    key: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheHasResponse {
    #[serde(default)]
    exists: bool,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct CacheRemoveRequest {
    key: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CacheRemoveResponse {
    #[serde(default)]
    error: Option<String>,
}

#[host_fn]
extern "ExtismHost" {
    fn cache_setstring(input: Json<CacheSetStringRequest>) -> Json<CacheSetStringResponse>;
    fn cache_getstring(input: Json<CacheGetStringRequest>) -> Json<CacheGetStringResponse>;
    fn cache_setint(input: Json<CacheSetIntRequest>) -> Json<CacheSetIntResponse>;
    fn cache_getint(input: Json<CacheGetIntRequest>) -> Json<CacheGetIntResponse>;
    fn cache_setfloat(input: Json<CacheSetFloatRequest>) -> Json<CacheSetFloatResponse>;
    fn cache_getfloat(input: Json<CacheGetFloatRequest>) -> Json<CacheGetFloatResponse>;
    fn cache_setbytes(input: Json<CacheSetBytesRequest>) -> Json<CacheSetBytesResponse>;
    fn cache_getbytes(input: Json<CacheGetBytesRequest>) -> Json<CacheGetBytesResponse>;
    fn cache_has(input: Json<CacheHasRequest>) -> Json<CacheHasResponse>;
    fn cache_remove(input: Json<CacheRemoveRequest>) -> Json<CacheRemoveResponse>;
}

/// SetString stores a string value in the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
///   - value: The string value to store
///   - ttlSeconds: Time-to-live in seconds (0 uses default of 24 hours)
/// 
/// Returns an error if the operation fails.
///
/// # Arguments
/// * `key` - String parameter.
/// * `value` - String parameter.
/// * `ttl_seconds` - i64 parameter.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn set_string(key: &str, value: &str, ttl_seconds: i64) -> Result<(), Error> {
    let response = unsafe {
        cache_setstring(Json(CacheSetStringRequest {
            key: key.to_owned(),
            value: value.to_owned(),
            ttl_seconds: ttl_seconds,
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(())
}

/// GetString retrieves a string value from the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
/// 
/// Returns the value and whether the key exists. If the key doesn't exist
/// or the stored value is not a string, exists will be false.
///
/// # Arguments
/// * `key` - String parameter.
///
/// # Returns
/// `Some(value)` if found, `None` otherwise.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn get_string(key: &str) -> Result<Option<String>, Error> {
    let response = unsafe {
        cache_getstring(Json(CacheGetStringRequest {
            key: key.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    if response.0.exists {
        Ok(Some(response.0.value))
    } else {
        Ok(None)
    }
}

/// SetInt stores an integer value in the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
///   - value: The integer value to store
///   - ttlSeconds: Time-to-live in seconds (0 uses default of 24 hours)
/// 
/// Returns an error if the operation fails.
///
/// # Arguments
/// * `key` - String parameter.
/// * `value` - i64 parameter.
/// * `ttl_seconds` - i64 parameter.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn set_int(key: &str, value: i64, ttl_seconds: i64) -> Result<(), Error> {
    let response = unsafe {
        cache_setint(Json(CacheSetIntRequest {
            key: key.to_owned(),
            value: value,
            ttl_seconds: ttl_seconds,
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(())
}

/// GetInt retrieves an integer value from the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
/// 
/// Returns the value and whether the key exists. If the key doesn't exist
/// or the stored value is not an integer, exists will be false.
///
/// # Arguments
/// * `key` - String parameter.
///
/// # Returns
/// `Some(value)` if found, `None` otherwise.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn get_int(key: &str) -> Result<Option<i64>, Error> {
    let response = unsafe {
        cache_getint(Json(CacheGetIntRequest {
            key: key.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    if response.0.exists {
        Ok(Some(response.0.value))
    } else {
        Ok(None)
    }
}

/// SetFloat stores a float value in the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
///   - value: The float value to store
///   - ttlSeconds: Time-to-live in seconds (0 uses default of 24 hours)
/// 
/// Returns an error if the operation fails.
///
/// # Arguments
/// * `key` - String parameter.
/// * `value` - f64 parameter.
/// * `ttl_seconds` - i64 parameter.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn set_float(key: &str, value: f64, ttl_seconds: i64) -> Result<(), Error> {
    let response = unsafe {
        cache_setfloat(Json(CacheSetFloatRequest {
            key: key.to_owned(),
            value: value,
            ttl_seconds: ttl_seconds,
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(())
}

/// GetFloat retrieves a float value from the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
/// 
/// Returns the value and whether the key exists. If the key doesn't exist
/// or the stored value is not a float, exists will be false.
///
/// # Arguments
/// * `key` - String parameter.
///
/// # Returns
/// `Some(value)` if found, `None` otherwise.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn get_float(key: &str) -> Result<Option<f64>, Error> {
    let response = unsafe {
        cache_getfloat(Json(CacheGetFloatRequest {
            key: key.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    if response.0.exists {
        Ok(Some(response.0.value))
    } else {
        Ok(None)
    }
}

/// SetBytes stores a byte slice in the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
///   - value: The byte slice to store
///   - ttlSeconds: Time-to-live in seconds (0 uses default of 24 hours)
/// 
/// Returns an error if the operation fails.
///
/// # Arguments
/// * `key` - String parameter.
/// * `value` - Vec<u8> parameter.
/// * `ttl_seconds` - i64 parameter.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn set_bytes(key: &str, value: Vec<u8>, ttl_seconds: i64) -> Result<(), Error> {
    let response = unsafe {
        cache_setbytes(Json(CacheSetBytesRequest {
            key: key.to_owned(),
            value: value,
            ttl_seconds: ttl_seconds,
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(())
}

/// GetBytes retrieves a byte slice from the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
/// 
/// Returns the value and whether the key exists. If the key doesn't exist
/// or the stored value is not a byte slice, exists will be false.
///
/// # Arguments
/// * `key` - String parameter.
///
/// # Returns
/// `Some(value)` if found, `None` otherwise.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn get_bytes(key: &str) -> Result<Option<Vec<u8>>, Error> {
    let response = unsafe {
        cache_getbytes(Json(CacheGetBytesRequest {
            key: key.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    if response.0.exists {
        Ok(Some(response.0.value))
    } else {
        Ok(None)
    }
}

/// Has checks if a key exists in the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
/// 
/// Returns true if the key exists and has not expired.
///
/// # Arguments
/// * `key` - String parameter.
///
/// # Returns
/// The exists value.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn has(key: &str) -> Result<bool, Error> {
    let response = unsafe {
        cache_has(Json(CacheHasRequest {
            key: key.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(response.0.exists)
}

/// Remove deletes a value from the cache.
/// 
/// Parameters:
///   - key: The cache key (will be namespaced with plugin ID)
/// 
/// Returns an error if the operation fails. Does not return an error if the key doesn't exist.
///
/// # Arguments
/// * `key` - String parameter.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn remove(key: &str) -> Result<(), Error> {
    let response = unsafe {
        cache_remove(Json(CacheRemoveRequest {
            key: key.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(())
}
