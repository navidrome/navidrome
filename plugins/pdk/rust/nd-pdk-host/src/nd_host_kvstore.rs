// Code generated by ndpgen. DO NOT EDIT.
//
// This file contains client wrappers for the KVStore host service.
// It is intended for use in Navidrome plugins built with extism-pdk.

use extism_pdk::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreSetRequest {
    key: String,
    value: Vec<u8>,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreSetResponse {
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreGetRequest {
    key: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreGetResponse {
    #[serde(default)]
    value: Vec<u8>,
    #[serde(default)]
    exists: bool,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreDeleteRequest {
    key: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreDeleteResponse {
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreHasRequest {
    key: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreHasResponse {
    #[serde(default)]
    exists: bool,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreListRequest {
    prefix: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreListResponse {
    #[serde(default)]
    keys: Vec<String>,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct KVStoreGetStorageUsedResponse {
    #[serde(default)]
    bytes: i64,
    #[serde(default)]
    error: Option<String>,
}

#[host_fn]
extern "ExtismHost" {
    fn kvstore_set(input: Json<KVStoreSetRequest>) -> Json<KVStoreSetResponse>;
    fn kvstore_get(input: Json<KVStoreGetRequest>) -> Json<KVStoreGetResponse>;
    fn kvstore_delete(input: Json<KVStoreDeleteRequest>) -> Json<KVStoreDeleteResponse>;
    fn kvstore_has(input: Json<KVStoreHasRequest>) -> Json<KVStoreHasResponse>;
    fn kvstore_list(input: Json<KVStoreListRequest>) -> Json<KVStoreListResponse>;
    fn kvstore_getstorageused(input: Json<serde_json::Value>) -> Json<KVStoreGetStorageUsedResponse>;
}

/// Set stores a byte value with the given key.
/// 
/// Parameters:
///   - key: The storage key (max 256 bytes, UTF-8)
///   - value: The byte slice to store
/// 
/// Returns an error if the storage limit would be exceeded or the operation fails.
///
/// # Arguments
/// * `key` - String parameter.
/// * `value` - Vec<u8> parameter.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn set(key: &str, value: Vec<u8>) -> Result<(), Error> {
    let response = unsafe {
        kvstore_set(Json(KVStoreSetRequest {
            key: key.to_owned(),
            value: value,
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(())
}

/// Get retrieves a byte value from storage.
/// 
/// Parameters:
///   - key: The storage key
/// 
/// Returns the value and whether the key exists.
///
/// # Arguments
/// * `key` - String parameter.
///
/// # Returns
/// `Some(value)` if found, `None` otherwise.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn get(key: &str) -> Result<Option<Vec<u8>>, Error> {
    let response = unsafe {
        kvstore_get(Json(KVStoreGetRequest {
            key: key.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    if response.0.exists {
        Ok(Some(response.0.value))
    } else {
        Ok(None)
    }
}

/// Delete removes a value from storage.
/// 
/// Parameters:
///   - key: The storage key
/// 
/// Returns an error if the operation fails. Does not return an error if the key doesn't exist.
///
/// # Arguments
/// * `key` - String parameter.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn delete(key: &str) -> Result<(), Error> {
    let response = unsafe {
        kvstore_delete(Json(KVStoreDeleteRequest {
            key: key.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(())
}

/// Has checks if a key exists in storage.
/// 
/// Parameters:
///   - key: The storage key
/// 
/// Returns true if the key exists.
///
/// # Arguments
/// * `key` - String parameter.
///
/// # Returns
/// The exists value.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn has(key: &str) -> Result<bool, Error> {
    let response = unsafe {
        kvstore_has(Json(KVStoreHasRequest {
            key: key.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(response.0.exists)
}

/// List returns all keys matching the given prefix.
/// 
/// Parameters:
///   - prefix: Key prefix to filter by (empty string returns all keys)
/// 
/// Returns a slice of matching keys.
///
/// # Arguments
/// * `prefix` - String parameter.
///
/// # Returns
/// The keys value.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn list(prefix: &str) -> Result<Vec<String>, Error> {
    let response = unsafe {
        kvstore_list(Json(KVStoreListRequest {
            prefix: prefix.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(response.0.keys)
}

/// GetStorageUsed returns the total storage used by this plugin in bytes.
///
/// # Returns
/// The bytes value.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn get_storage_used() -> Result<i64, Error> {
    let response = unsafe {
        kvstore_getstorageused(Json(serde_json::json!({})))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(response.0.bytes)
}
