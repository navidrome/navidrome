// Code generated by ndpgen. DO NOT EDIT.
//
// This file contains client wrappers for the Scheduler host service.
// It is intended for use in Navidrome plugins built with extism-pdk.

use extism_pdk::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct SchedulerScheduleOneTimeRequest {
    delay_seconds: i32,
    payload: String,
    schedule_id: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct SchedulerScheduleOneTimeResponse {
    #[serde(default)]
    new_schedule_id: String,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct SchedulerScheduleRecurringRequest {
    cron_expression: String,
    payload: String,
    schedule_id: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct SchedulerScheduleRecurringResponse {
    #[serde(default)]
    new_schedule_id: String,
    #[serde(default)]
    error: Option<String>,
}

#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct SchedulerCancelScheduleRequest {
    schedule_id: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
struct SchedulerCancelScheduleResponse {
    #[serde(default)]
    error: Option<String>,
}

#[host_fn]
extern "ExtismHost" {
    fn scheduler_scheduleonetime(input: Json<SchedulerScheduleOneTimeRequest>) -> Json<SchedulerScheduleOneTimeResponse>;
    fn scheduler_schedulerecurring(input: Json<SchedulerScheduleRecurringRequest>) -> Json<SchedulerScheduleRecurringResponse>;
    fn scheduler_cancelschedule(input: Json<SchedulerCancelScheduleRequest>) -> Json<SchedulerCancelScheduleResponse>;
}

/// ScheduleOneTime schedules a one-time event to be triggered after the specified delay.
/// Plugins that use this function must also implement the SchedulerCallback capability
/// 
/// Parameters:
///   - delaySeconds: Number of seconds to wait before triggering the event
///   - payload: Data to be passed to the scheduled event handler
///   - scheduleID: Optional unique identifier for the scheduled job. If empty, one will be generated
/// 
/// Returns the schedule ID that can be used to cancel the job, or an error if scheduling fails.
///
/// # Arguments
/// * `delay_seconds` - i32 parameter.
/// * `payload` - String parameter.
/// * `schedule_id` - String parameter.
///
/// # Returns
/// The new_schedule_id value.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn schedule_one_time(delay_seconds: i32, payload: &str, schedule_id: &str) -> Result<String, Error> {
    let response = unsafe {
        scheduler_scheduleonetime(Json(SchedulerScheduleOneTimeRequest {
            delay_seconds: delay_seconds,
            payload: payload.to_owned(),
            schedule_id: schedule_id.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(response.0.new_schedule_id)
}

/// ScheduleRecurring schedules a recurring event using a cron expression.
/// Plugins that use this function must also implement the SchedulerCallback capability
/// 
/// Parameters:
///   - cronExpression: Standard cron format expression (e.g., "0 0 * * *" for daily at midnight)
///   - payload: Data to be passed to each scheduled event handler invocation
///   - scheduleID: Optional unique identifier for the scheduled job. If empty, one will be generated
/// 
/// Returns the schedule ID that can be used to cancel the job, or an error if scheduling fails.
///
/// # Arguments
/// * `cron_expression` - String parameter.
/// * `payload` - String parameter.
/// * `schedule_id` - String parameter.
///
/// # Returns
/// The new_schedule_id value.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn schedule_recurring(cron_expression: &str, payload: &str, schedule_id: &str) -> Result<String, Error> {
    let response = unsafe {
        scheduler_schedulerecurring(Json(SchedulerScheduleRecurringRequest {
            cron_expression: cron_expression.to_owned(),
            payload: payload.to_owned(),
            schedule_id: schedule_id.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(response.0.new_schedule_id)
}

/// CancelSchedule cancels a scheduled job identified by its schedule ID.
/// 
/// This works for both one-time and recurring schedules. Once cancelled, the job will not trigger
/// any future events.
/// 
/// Returns an error if the schedule ID is not found or if cancellation fails.
///
/// # Arguments
/// * `schedule_id` - String parameter.
///
/// # Errors
/// Returns an error if the host function call fails.
pub fn cancel_schedule(schedule_id: &str) -> Result<(), Error> {
    let response = unsafe {
        scheduler_cancelschedule(Json(SchedulerCancelScheduleRequest {
            schedule_id: schedule_id.to_owned(),
        }))?
    };

    if let Some(err) = response.0.error {
        return Err(Error::msg(err));
    }

    Ok(())
}
