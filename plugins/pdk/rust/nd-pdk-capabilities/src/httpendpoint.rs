// Code generated by ndpgen. DO NOT EDIT.
//
// This file contains export wrappers for the HTTPEndpoint capability.
// It is intended for use in Navidrome plugins built with extism-pdk.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// Helper functions for skip_serializing_if with numeric types
#[allow(dead_code)]
fn is_zero_i32(value: &i32) -> bool { *value == 0 }
#[allow(dead_code)]
fn is_zero_u32(value: &u32) -> bool { *value == 0 }
#[allow(dead_code)]
fn is_zero_i64(value: &i64) -> bool { *value == 0 }
#[allow(dead_code)]
fn is_zero_u64(value: &u64) -> bool { *value == 0 }
#[allow(dead_code)]
fn is_zero_f32(value: &f32) -> bool { *value == 0.0 }
#[allow(dead_code)]
fn is_zero_f64(value: &f64) -> bool { *value == 0.0 }
/// HTTPHandleRequest is the input provided when an HTTP request is dispatched to a plugin.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HTTPHandleRequest {
    /// Method is the HTTP method (GET, POST, PUT, DELETE, PATCH, etc.).
    #[serde(default)]
    pub method: String,
    /// Path is the request path relative to the plugin's base URL.
    /// For example, if the full URL is /ext/my-plugin/webhook, Path is "/webhook".
    #[serde(default)]
    pub path: String,
    /// Query is the raw query string without the leading '?'.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub query: String,
    /// Headers contains the HTTP request headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: std::collections::HashMap<String, Vec<String>>,
    /// Body is the request body content.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub body: String,
    /// User contains the authenticated user information. Nil for auth:"none" endpoints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<HTTPUser>,
}
/// HTTPHandleResponse is the response returned by the plugin's HandleRequest function.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HTTPHandleResponse {
    /// Status is the HTTP status code. Defaults to 200 if zero or not set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: i32,
    /// Headers contains the HTTP response headers to set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: std::collections::HashMap<String, Vec<String>>,
    /// Body is the response body content.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub body: String,
}
/// HTTPUser contains authenticated user information passed to the plugin.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HTTPUser {
    /// ID is the internal Navidrome user ID.
    #[serde(default)]
    pub id: String,
    /// Username is the user's login name.
    #[serde(default)]
    pub username: String,
    /// Name is the user's display name.
    #[serde(default)]
    pub name: String,
    /// IsAdmin indicates whether the user has admin privileges.
    #[serde(default)]
    pub is_admin: bool,
}

/// Error represents an error from a capability method.
#[derive(Debug)]
pub struct Error {
    pub message: String,
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for Error {}

impl Error {
    pub fn new(message: impl Into<String>) -> Self {
        Self { message: message.into() }
    }
}

/// HTTPEndpoint requires all methods to be implemented.
/// HTTPEndpoint allows plugins to handle incoming HTTP requests.
/// Plugins that declare the 'endpoints' permission must implement this capability.
/// The host dispatches incoming HTTP requests to the plugin's HandleRequest function.
pub trait HTTPEndpoint {
    /// HandleRequest - HandleRequest processes an incoming HTTP request and returns a response.
    fn handle_request(&self, req: HTTPHandleRequest) -> Result<HTTPHandleResponse, Error>;
}

/// Register all exports for the HTTPEndpoint capability.
/// This macro generates the WASM export functions for all trait methods.
#[macro_export]
macro_rules! register_httpendpoint {
    ($plugin_type:ty) => {
        #[extism_pdk::plugin_fn]
        pub fn nd_http_handle_request(
            req: extism_pdk::Json<$crate::httpendpoint::HTTPHandleRequest>
        ) -> extism_pdk::FnResult<extism_pdk::Json<$crate::httpendpoint::HTTPHandleResponse>> {
            let plugin = <$plugin_type>::default();
            let result = $crate::httpendpoint::HTTPEndpoint::handle_request(&plugin, req.into_inner())?;
            Ok(extism_pdk::Json(result))
        }
    };
}
