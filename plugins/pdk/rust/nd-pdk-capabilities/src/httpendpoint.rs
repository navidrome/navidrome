// Code generated by ndpgen. DO NOT EDIT.
//
// This file contains export wrappers for the HTTPEndpoint capability.
// It is intended for use in Navidrome plugins built with extism-pdk.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// Helper functions for skip_serializing_if with numeric types
#[allow(dead_code)]
fn is_zero_i32(value: &i32) -> bool { *value == 0 }
#[allow(dead_code)]
fn is_zero_u32(value: &u32) -> bool { *value == 0 }
#[allow(dead_code)]
fn is_zero_i64(value: &i64) -> bool { *value == 0 }
#[allow(dead_code)]
fn is_zero_u64(value: &u64) -> bool { *value == 0 }
#[allow(dead_code)]
fn is_zero_f32(value: &f32) -> bool { *value == 0.0 }
#[allow(dead_code)]
fn is_zero_f64(value: &f64) -> bool { *value == 0.0 }
/// HTTPHandleRequest is the input provided when an HTTP request is dispatched to a plugin.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HTTPHandleRequest {
    /// Method is the HTTP method (GET, POST, PUT, DELETE, PATCH, etc.).
    #[serde(default)]
    pub method: String,
    /// Path is the request path relative to the plugin's base URL.
    /// For example, if the full URL is /ext/my-plugin/webhook, Path is "/webhook".
    /// Both /ext/my-plugin and /ext/my-plugin/ are normalized to Path = "".
    #[serde(default)]
    pub path: String,
    /// Query is the raw query string without the leading '?'.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub query: String,
    /// Headers contains the HTTP request headers.
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub headers: std::collections::HashMap<String, Vec<String>>,
    /// Body is the request body content.
    #[serde(skip)]
    pub body: Vec<u8>,
    /// User contains the authenticated user information. Nil for auth:"none" endpoints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<HTTPUser>,
}
/// HTTPHandleResponse is the response returned by the plugin's HandleRequest function.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HTTPHandleResponse {
    /// Status is the HTTP status code. Defaults to 200 if zero or not set.
    #[serde(default, skip_serializing_if = "is_zero_i32")]
    pub status: i32,
    /// Headers contains the HTTP response headers to set.
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub headers: std::collections::HashMap<String, Vec<String>>,
    /// Body is the response body content.
    #[serde(skip)]
    pub body: Vec<u8>,
}
/// HTTPUser contains authenticated user information passed to the plugin.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HTTPUser {
    /// ID is the internal Navidrome user ID.
    #[serde(default)]
    pub id: String,
    /// Username is the user's login name.
    #[serde(default)]
    pub username: String,
    /// Name is the user's display name.
    #[serde(default)]
    pub name: String,
    /// IsAdmin indicates whether the user has admin privileges.
    #[serde(default)]
    pub is_admin: bool,
}

/// Error represents an error from a capability method.
#[derive(Debug)]
pub struct Error {
    pub message: String,
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for Error {}

impl Error {
    pub fn new(message: impl Into<String>) -> Self {
        Self { message: message.into() }
    }
}

/// HTTPEndpoint requires all methods to be implemented.
/// HTTPEndpoint allows plugins to handle incoming HTTP requests.
/// Plugins that declare the 'endpoints' permission must implement this capability.
/// The host dispatches incoming HTTP requests to the plugin's HandleRequest function.
pub trait HTTPEndpoint {
    /// HandleRequest - HandleRequest processes an incoming HTTP request and returns a response.
    fn handle_request(&self, req: HTTPHandleRequest) -> Result<HTTPHandleResponse, Error>;
}

/// Register all exports for the HTTPEndpoint capability.
/// This macro generates the WASM export functions for all trait methods.
#[macro_export]
macro_rules! register_httpendpoint {
    ($plugin_type:ty) => {
        #[extism_pdk::plugin_fn]
        pub fn nd_http_handle_request(
            _raw_input: extism_pdk::Raw<Vec<u8>>
        ) -> extism_pdk::FnResult<extism_pdk::Raw<Vec<u8>>> {
            let plugin = <$plugin_type>::default();
            // Parse input frame: [json_len:4B][JSON without []byte field][raw bytes]
            let raw_bytes = _raw_input.0;
            if raw_bytes.len() < 4 {
                let mut err_frame = vec![0x01u8];
                err_frame.extend_from_slice(b"malformed input frame");
                return Ok(extism_pdk::Raw(err_frame));
            }
            let json_len = u32::from_be_bytes([raw_bytes[0], raw_bytes[1], raw_bytes[2], raw_bytes[3]]) as usize;
            if json_len > raw_bytes.len() - 4 {
                let mut err_frame = vec![0x01u8];
                err_frame.extend_from_slice(b"invalid json length in input frame");
                return Ok(extism_pdk::Raw(err_frame));
            }
            let mut req: $crate::httpendpoint::HTTPHandleRequest = serde_json::from_slice(&raw_bytes[4..4+json_len])
                .map_err(|e| extism_pdk::Error::msg(e.to_string()))?;
            req.body = raw_bytes[4+json_len..].to_vec();
            match $crate::httpendpoint::HTTPEndpoint::handle_request(&plugin, req) {
                Ok(output) => {
                    // Success frame: [0x00][json_len:4B][JSON without []byte field][raw bytes]
                    let json_bytes = serde_json::to_vec(&output)
                        .map_err(|e| extism_pdk::Error::msg(e.to_string()))?;
                    let raw_field = &output.body;
                    let mut frame = Vec::with_capacity(1 + 4 + json_bytes.len() + raw_field.len());
                    frame.push(0x00);
                    frame.extend_from_slice(&(json_bytes.len() as u32).to_be_bytes());
                    frame.extend_from_slice(&json_bytes);
                    frame.extend_from_slice(raw_field);
                    Ok(extism_pdk::Raw(frame))
                }
                Err(e) => {
                    // Error frame: [0x01][UTF-8 error message]
                    let mut err_frame = vec![0x01u8];
                    err_frame.extend_from_slice(e.message.as_bytes());
                    Ok(extism_pdk::Raw(err_frame))
                }
            }
        }
    };
}
