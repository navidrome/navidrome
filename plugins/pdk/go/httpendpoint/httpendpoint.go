// Code generated by ndpgen. DO NOT EDIT.
//
// This file contains export wrappers for the HTTPEndpoint capability.
// It is intended for use in Navidrome plugins built with TinyGo.
//
//go:build wasip1

package httpendpoint

import (
	"encoding/binary"
	"encoding/json"

	"github.com/navidrome/navidrome/plugins/pdk/go/pdk"
)

// HTTPHandleRequest is the input provided when an HTTP request is dispatched to a plugin.
type HTTPHandleRequest struct {
	// Method is the HTTP method (GET, POST, PUT, DELETE, PATCH, etc.).
	Method string `json:"method"`
	// Path is the request path relative to the plugin's base URL.
	// For example, if the full URL is /ext/my-plugin/webhook, Path is "/webhook".
	// Both /ext/my-plugin and /ext/my-plugin/ are normalized to Path = "".
	Path string `json:"path"`
	// Query is the raw query string without the leading '?'.
	Query string `json:"query,omitempty"`
	// Headers contains the HTTP request headers.
	Headers map[string][]string `json:"headers,omitempty"`
	// Body is the request body content.
	Body []byte `json:"-"`
	// User contains the authenticated user information. Nil for auth:"none" endpoints.
	User *HTTPUser `json:"user,omitempty"`
}

// HTTPHandleResponse is the response returned by the plugin's HandleRequest function.
type HTTPHandleResponse struct {
	// Status is the HTTP status code. Defaults to 200 if zero or not set.
	Status int32 `json:"status,omitempty"`
	// Headers contains the HTTP response headers to set.
	Headers map[string][]string `json:"headers,omitempty"`
	// Body is the response body content.
	Body []byte `json:"-"`
}

// HTTPUser contains authenticated user information passed to the plugin.
type HTTPUser struct {
	// ID is the internal Navidrome user ID.
	ID string `json:"id"`
	// Username is the user's login name.
	Username string `json:"username"`
	// Name is the user's display name.
	Name string `json:"name"`
	// IsAdmin indicates whether the user has admin privileges.
	IsAdmin bool `json:"isAdmin"`
}

// HTTPEndpoint requires all methods to be implemented.
// HTTPEndpoint allows plugins to handle incoming HTTP requests.
// Plugins that declare the 'endpoints' permission must implement this capability.
// The host dispatches incoming HTTP requests to the plugin's HandleRequest function.
type HTTPEndpoint interface {
	// HandleRequest - HandleRequest processes an incoming HTTP request and returns a response.
	HandleRequest(HTTPHandleRequest) (HTTPHandleResponse, error)
} // Internal implementation holders
var (
	handleRequestImpl func(HTTPHandleRequest) (HTTPHandleResponse, error)
)

// Register registers a httpendpoint implementation.
// All methods are required.
func Register(impl HTTPEndpoint) {
	handleRequestImpl = impl.HandleRequest
}

// NotImplementedCode is the standard return code for unimplemented functions.
// The host recognizes this and skips the plugin gracefully.
const NotImplementedCode int32 = -2

//go:wasmexport nd_http_handle_request
func _NdHttpHandleRequest() int32 {
	if handleRequestImpl == nil {
		// Return standard code - host will skip this plugin gracefully
		return NotImplementedCode
	}

	// Parse input frame: [json_len:4B][JSON without []byte field][raw bytes]
	raw := pdk.Input()
	if len(raw) < 4 {
		pdk.SetErrorString("malformed input frame")
		return -1
	}
	jsonLen := binary.BigEndian.Uint32(raw[:4])
	if uint32(len(raw)-4) < jsonLen {
		pdk.SetErrorString("invalid json length in input frame")
		return -1
	}
	var input HTTPHandleRequest
	if err := json.Unmarshal(raw[4:4+jsonLen], &input); err != nil {
		pdk.SetError(err)
		return -1
	}
	input.Body = raw[4+jsonLen:]

	output, err := handleRequestImpl(input)
	if err != nil {
		// Error frame: [0x01][UTF-8 error message]
		errMsg := []byte(err.Error())
		errFrame := make([]byte, 1+len(errMsg))
		errFrame[0] = 0x01
		copy(errFrame[1:], errMsg)
		pdk.Output(errFrame)
		return 0
	}

	// Success frame: [0x00][json_len:4B][JSON without []byte field][raw bytes]
	jsonBytes, _ := json.Marshal(output)
	rawBytes := output.Body
	frame := make([]byte, 1+4+len(jsonBytes)+len(rawBytes))
	frame[0] = 0x00
	binary.BigEndian.PutUint32(frame[1:5], uint32(len(jsonBytes)))
	copy(frame[5:5+len(jsonBytes)], jsonBytes)
	copy(frame[5+len(jsonBytes):], rawBytes)
	pdk.Output(frame)

	return 0
}
