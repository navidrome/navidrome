// Code generated by hostgen. DO NOT EDIT.
//
// This file contains client wrappers for the {{.Service.Name}} host service.
// It is intended for use in Navidrome plugins built with TinyGo.
//
//go:build wasip1

package main

import (
{{- if .NeedsJSON}}
	"encoding/json"
{{- end}}
{{- if .NeedsErrors}}
	"errors"
{{- end}}

	"github.com/extism/go-pdk"
)

{{- /* Generate wasmimport declarations for each method */ -}}
{{range .Service.Methods}}

// {{exportName .}} is the host function provided by Navidrome.
//
//go:wasmimport extism:host/user {{exportName .}}
func {{exportName .}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{wasmParamType $p}}{{end}}) {{wasmReturnType .}}
{{- end}}

{{- /* Generate response types for methods that need them */ -}}
{{range .Service.Methods}}
{{- if needsRespType .}}

// {{responseType .}} is the response type for {{$.Service.Name}}.{{.Name}}.
type {{responseType .}} struct {
{{- range .Returns}}
	{{title .Name}} {{.Type}} `json:"{{.JSONName}},omitempty"`
{{- end}}
	Error string `json:"error,omitempty"`
}
{{- end}}
{{- end}}

{{- /* Generate wrapper functions */ -}}
{{range .Service.Methods}}

// {{$.Service.Name}}{{.Name}} calls the {{exportName .}} host function.
{{- if .Doc}}
{{formatDoc .Doc}}
{{- end}}
func {{$.Service.Name}}{{.Name}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{$p.Name}} {{$p.Type}}{{end}}) {{wrapperReturnType . $.Service.Name}} {
{{- if needsRespType .}}
{{- /* Complex response - use JSON */}}
{{- range .Params}}
{{- if isString .Type}}
	{{.Name}}Mem := pdk.AllocateString({{.Name}})
	defer {{.Name}}Mem.Free()
{{- else if isBytes .Type}}
	{{.Name}}Mem := pdk.AllocateBytes({{.Name}})
	defer {{.Name}}Mem.Free()
{{- else if needsJSON .Type}}
	{{.Name}}Bytes, err := json.Marshal({{.Name}})
	if err != nil {
		return nil, err
	}
	{{.Name}}Mem := pdk.AllocateBytes({{.Name}}Bytes)
	defer {{.Name}}Mem.Free()
{{- end}}
{{- end}}

	// Call the host function
	responsePtr := {{exportName .}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{clientCallArg $p}}{{end}})

	// Read the response from memory
	responseMem := pdk.FindMemory(responsePtr)
	responseBytes := responseMem.ReadBytes()

	// Parse the response
	var response {{responseType .}}
	if err := json.Unmarshal(responseBytes, &response); err != nil {
		return nil, err
	}

	return &response, nil
{{- else if isErrorOnly .}}
{{- /* Error-only response - string result */}}
{{- range .Params}}
{{- if isString .Type}}
	{{.Name}}Mem := pdk.AllocateString({{.Name}})
	defer {{.Name}}Mem.Free()
{{- else if isBytes .Type}}
	{{.Name}}Mem := pdk.AllocateBytes({{.Name}})
	defer {{.Name}}Mem.Free()
{{- else if needsJSON .Type}}
	{{.Name}}Bytes, err := json.Marshal({{.Name}})
	if err != nil {
		return err
	}
	{{.Name}}Mem := pdk.AllocateBytes({{.Name}}Bytes)
	defer {{.Name}}Mem.Free()
{{- end}}
{{- end}}

	// Call the host function
	responsePtr := {{exportName .}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{clientCallArg $p}}{{end}})

	// Read the response from memory
	responseMem := pdk.FindMemory(responsePtr)
	errStr := string(responseMem.ReadBytes())

	if errStr != "" {
		return errors.New(errStr)
	}

	return nil
{{- else}}
{{- /* Simple return types - direct stack values */}}
{{- range .Params}}
{{- if isString .Type}}
	{{.Name}}Mem := pdk.AllocateString({{.Name}})
	defer {{.Name}}Mem.Free()
{{- else if isBytes .Type}}
	{{.Name}}Mem := pdk.AllocateBytes({{.Name}})
	defer {{.Name}}Mem.Free()
{{- end}}
{{- end}}

	// Call the host function
{{- if .HasReturns}}
	result := {{exportName .}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{clientCallArg $p}}{{end}})
	return {{decodeResult (index .Returns 0) "result"}}
{{- else}}
	{{exportName .}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{clientCallArg $p}}{{end}})
{{- end}}
{{- end}}
}
{{- end}}
