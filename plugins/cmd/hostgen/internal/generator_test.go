package internal

import (
	"go/format"
	"os"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Generator", func() {
	Describe("GenerateHost", func() {
		It("should generate valid Go code for a simple service with strings", func() {
			// All methods use JSON request/response types
			svc := Service{
				Name:       "SubsonicAPI",
				Permission: "subsonicapi",
				Interface:  "SubsonicAPIService",
				Methods: []Method{
					{
						Name:     "Call",
						HasError: true,
						Params:   []Param{NewParam("uri", "string")},
						Returns:  []Param{NewParam("response", "string")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			// Verify the code is valid Go
			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)

			// Check for generated header
			Expect(codeStr).To(ContainSubstring("Code generated by hostgen. DO NOT EDIT."))

			// Check for package declaration
			Expect(codeStr).To(ContainSubstring("package host"))

			// All methods now use request type for JSON protocol
			Expect(codeStr).To(ContainSubstring("type SubsonicAPICallRequest struct"))
			Expect(codeStr).To(ContainSubstring(`Uri string `))

			// Response type with error handling
			Expect(codeStr).To(ContainSubstring("type SubsonicAPICallResponse struct"))
			Expect(codeStr).To(ContainSubstring(`Response string `))
			Expect(codeStr).To(ContainSubstring(`Error string `))

			// Check for registration function
			Expect(codeStr).To(ContainSubstring("func RegisterSubsonicAPIHostFunctions(service SubsonicAPIService)"))

			// Check for host function name
			Expect(codeStr).To(ContainSubstring(`"subsonicapi_call"`))

			// Check for JSON unmarshal (all methods use JSON now)
			Expect(codeStr).To(ContainSubstring("json.Unmarshal"))
		})

		It("should generate code for methods without parameters", func() {
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "NoParams",
						HasError: true,
						Returns:  []Param{NewParam("result", "string")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			// Methods without params don't need a request type - no params to serialize
			Expect(codeStr).NotTo(ContainSubstring("type TestNoParamsRequest struct"))
			// But still uses PTR input/output for consistency
			Expect(codeStr).To(MatchRegexp(`\[\]extism\.ValueType\{extism\.ValueTypePTR\},\s*\[\]extism\.ValueType\{extism\.ValueTypePTR\}`))
		})

		It("should generate code for methods without return values", func() {
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "NoReturn",
						HasError: true,
						Params:   []Param{NewParam("input", "string")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should generate code for multiple methods", func() {
			svc := Service{
				Name:       "Scheduler",
				Permission: "scheduler",
				Interface:  "SchedulerService",
				Methods: []Method{
					{
						Name:     "ScheduleRecurring",
						HasError: true,
						Params:   []Param{NewParam("cronExpression", "string")},
						Returns:  []Param{NewParam("scheduleID", "string")},
					},
					{
						Name:     "ScheduleOneTime",
						HasError: true,
						Params:   []Param{NewParam("delaySeconds", "int32")},
						Returns:  []Param{NewParam("scheduleID", "string")},
					},
					{
						Name:     "CancelSchedule",
						HasError: true,
						Params:   []Param{NewParam("scheduleID", "string")},
						Returns:  []Param{NewParam("canceled", "bool")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			Expect(codeStr).To(ContainSubstring("scheduler_schedulerecurring"))
			Expect(codeStr).To(ContainSubstring("scheduler_scheduleonetime"))
			Expect(codeStr).To(ContainSubstring("scheduler_cancelschedule"))
		})

		It("should handle multiple simple parameters with JSON", func() {
			// All params use JSON - single PTR input
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "MultiParam",
						HasError: true,
						Params: []Param{
							NewParam("name", "string"),
							NewParam("count", "int32"),
							NewParam("enabled", "bool"),
						},
						Returns: []Param{NewParam("result", "string")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			// All methods use request type with JSON protocol
			Expect(codeStr).To(ContainSubstring("type TestMultiParamRequest struct"))
			// Check for JSON unmarshal (all methods use JSON now)
			Expect(codeStr).To(ContainSubstring("json.Unmarshal"))
			// Check that input/output ValueType both use PTR (JSON)
			Expect(codeStr).To(MatchRegexp(`\[\]extism\.ValueType\{extism\.ValueTypePTR\},\s*\[\]extism\.ValueType\{extism\.ValueTypePTR\}`))
		})

		It("should use single PTR for mixed simple and complex params", func() {
			// When any param needs JSON, all are bundled into one request struct
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "MixedParam",
						HasError: true,
						Params: []Param{
							NewParam("id", "string"),     // simple (PTR for string)
							NewParam("tags", "[]string"), // complex - needs JSON
						},
						Returns: []Param{NewParam("count", "int32")}, // simple
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			// Request type IS needed because of complex param
			Expect(codeStr).To(ContainSubstring("type TestMixedParamRequest struct"))
			// When using request type, only ONE PTR for input (the JSON request)
			Expect(codeStr).To(MatchRegexp(`\[\]extism\.ValueType\{extism\.ValueTypePTR\},\s*\[\]extism\.ValueType\{extism\.ValueTypePTR\}`))
		})

		It("should generate proper JSON tags for complex types", func() {
			// Complex types (structs, slices, maps) need JSON serialization
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "Method",
						HasError: true,
						Params:   []Param{NewParam("inputValue", "[]string")},           // slice needs JSON
						Returns:  []Param{NewParam("outputValue", "map[string]string")}, // map needs JSON
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			// Complex params need request type with JSON tags
			Expect(codeStr).To(ContainSubstring(`json:"inputValue"`))
			// Complex returns need response type with JSON tags
			Expect(codeStr).To(ContainSubstring(`json:"outputValue,omitempty"`))
		})

		It("should include required imports", func() {
			// Service with complex types needs JSON import
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "Method",
						HasError: true,
						Params:   []Param{NewParam("data", "MyStruct")}, // struct needs JSON
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			Expect(codeStr).To(ContainSubstring(`"context"`))
			Expect(codeStr).To(ContainSubstring(`"encoding/json"`))
			Expect(codeStr).To(ContainSubstring(`extism "github.com/extism/go-sdk"`))
		})

		It("should always include json import for JSON protocol", func() {
			// All services use JSON protocol, so json import is always needed
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:    "Method",
						Params:  []Param{NewParam("count", "int32")},
						Returns: []Param{NewParam("result", "int64")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			Expect(codeStr).To(ContainSubstring(`"context"`))
			Expect(codeStr).To(ContainSubstring(`"encoding/json"`))
			Expect(codeStr).To(ContainSubstring(`extism "github.com/extism/go-sdk"`))
		})
	})

	Describe("toJSONName", func() {
		It("should convert to camelCase matching Rust serde behavior", func() {
			Expect(toJSONName("InputValue")).To(Equal("inputValue"))
			Expect(toJSONName("URI")).To(Equal("uri"))
			Expect(toJSONName("id")).To(Equal("id"))
			Expect(toJSONName("ID")).To(Equal("id"))
			Expect(toJSONName("ConnectionID")).To(Equal("connectionId"))
			Expect(toJSONName("NewConnectionID")).To(Equal("newConnectionId"))
			Expect(toJSONName("XMLHTTPRequest")).To(Equal("xmlhttpRequest"))
			Expect(toJSONName("APIKey")).To(Equal("apiKey"))
		})

		It("should handle empty string", func() {
			Expect(toJSONName("")).To(Equal(""))
		})
	})

	Describe("NewParam", func() {
		It("should create param with auto-generated JSON name", func() {
			p := NewParam("MyParam", "string")
			Expect(p.Name).To(Equal("MyParam"))
			Expect(p.Type).To(Equal("string"))
			Expect(p.JSONName).To(Equal("myParam"))
		})
	})

	Describe("Python type and name helpers", func() {
		Describe("ToPythonType", func() {
			It("should map Go types to Python types", func() {
				Expect(ToPythonType("string")).To(Equal("str"))
				Expect(ToPythonType("int")).To(Equal("int"))
				Expect(ToPythonType("int32")).To(Equal("int"))
				Expect(ToPythonType("int64")).To(Equal("int"))
				Expect(ToPythonType("float32")).To(Equal("float"))
				Expect(ToPythonType("float64")).To(Equal("float"))
				Expect(ToPythonType("bool")).To(Equal("bool"))
				Expect(ToPythonType("[]byte")).To(Equal("bytes"))
				Expect(ToPythonType("unknown")).To(Equal("Any"))
			})
		})

		Describe("ToSnakeCase", func() {
			It("should convert PascalCase to snake_case", func() {
				Expect(ToSnakeCase("ScheduleRecurring")).To(Equal("schedule_recurring"))
				Expect(ToSnakeCase("GetString")).To(Equal("get_string"))
				Expect(ToSnakeCase("simple")).To(Equal("simple"))
			})

			It("should handle acronyms correctly", func() {
				Expect(ToSnakeCase("ID")).To(Equal("id"))
				Expect(ToSnakeCase("ScheduleID")).To(Equal("schedule_id"))
				Expect(ToSnakeCase("NewScheduleID")).To(Equal("new_schedule_id"))
				Expect(ToSnakeCase("XMLParser")).To(Equal("xml_parser"))
				Expect(ToSnakeCase("GetHTTPResponse")).To(Equal("get_http_response"))
			})
		})

		Describe("Method.PythonFunctionName", func() {
			It("should generate snake_case function name with service prefix", func() {
				m := Method{Name: "GetString"}
				Expect(m.PythonFunctionName("cache")).To(Equal("cache_get_string"))
			})
		})

		Describe("Param.PythonType", func() {
			It("should return Python type for parameter", func() {
				p := NewParam("value", "string")
				Expect(p.PythonType()).To(Equal("str"))
			})
		})

		Describe("Param.PythonName", func() {
			It("should return snake_case name for parameter", func() {
				p := NewParam("ttlSeconds", "int64")
				Expect(p.PythonName()).To(Equal("ttl_seconds"))
			})
		})
	})

	Describe("GenerateClientPython", func() {
		It("should generate valid Python code for a simple service", func() {
			svc := Service{
				Name:       "SubsonicAPI",
				Permission: "subsonicapi",
				Interface:  "SubsonicAPIService",
				Methods: []Method{
					{
						Name:     "Call",
						HasError: true,
						Params:   []Param{NewParam("uri", "string")},
						Returns:  []Param{NewParam("responseJSON", "string")},
					},
				},
			}

			code, err := GenerateClientPython(svc)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)

			// Check for generated header
			Expect(codeStr).To(ContainSubstring("Code generated by hostgen. DO NOT EDIT."))

			// Check for imports
			Expect(codeStr).To(ContainSubstring("from dataclasses import dataclass"))
			Expect(codeStr).To(ContainSubstring("import extism"))
			Expect(codeStr).To(ContainSubstring("import json"))

			// Check for exception class
			Expect(codeStr).To(ContainSubstring("class HostFunctionError(Exception):"))

			// Check for raw import function
			Expect(codeStr).To(ContainSubstring(`@extism.import_fn("extism:host/user", "subsonicapi_call")`))
			Expect(codeStr).To(ContainSubstring("def _subsonicapi_call(offset: int) -> int:"))

			// Check for wrapper function with type hints
			Expect(codeStr).To(ContainSubstring("def subsonicapi_call(uri: str) -> str:"))

			// Check for error handling
			Expect(codeStr).To(ContainSubstring("raise HostFunctionError(response["))
		})

		It("should generate dataclass for multi-value returns", func() {
			svc := Service{
				Name:       "Cache",
				Permission: "cache",
				Interface:  "CacheService",
				Methods: []Method{
					{
						Name:     "GetString",
						HasError: true,
						Params:   []Param{NewParam("key", "string")},
						Returns: []Param{
							NewParam("value", "string"),
							NewParam("exists", "bool"),
						},
					},
				},
			}

			code, err := GenerateClientPython(svc)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)

			// Check for dataclass
			Expect(codeStr).To(ContainSubstring("@dataclass"))
			Expect(codeStr).To(ContainSubstring("class CacheGetStringResult:"))
			Expect(codeStr).To(ContainSubstring("value: str"))
			Expect(codeStr).To(ContainSubstring("exists: bool"))

			// Check that function returns dataclass
			Expect(codeStr).To(ContainSubstring("def cache_get_string(key: str) -> CacheGetStringResult:"))
			Expect(codeStr).To(ContainSubstring("return CacheGetStringResult("))
		})

		It("should handle methods with no parameters", func() {
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "NoParams",
						HasError: true,
						Returns:  []Param{NewParam("result", "string")},
					},
				},
			}

			code, err := GenerateClientPython(svc)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)

			// Function with no params
			Expect(codeStr).To(ContainSubstring("def test_no_params() -> str:"))
			// Empty request
			Expect(codeStr).To(ContainSubstring(`request_bytes = b"{}"`))
		})

		It("should handle methods with no return values", func() {
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "NoReturn",
						HasError: true,
						Params:   []Param{NewParam("input", "string")},
					},
				},
			}

			code, err := GenerateClientPython(svc)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)

			// Function returns None
			Expect(codeStr).To(ContainSubstring("def test_no_return(input: str) -> None:"))
		})

		It("should generate correct Python defaults for different types", func() {
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "AllTypes",
						HasError: true,
						Returns: []Param{
							NewParam("strVal", "string"),
							NewParam("intVal", "int64"),
							NewParam("floatVal", "float64"),
							NewParam("boolVal", "bool"),
						},
					},
				},
			}

			code, err := GenerateClientPython(svc)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)

			// Check defaults in response.get() calls
			Expect(codeStr).To(ContainSubstring(`response.get("strVal", "")`))
			Expect(codeStr).To(ContainSubstring(`response.get("intVal", 0)`))
			Expect(codeStr).To(ContainSubstring(`response.get("floatVal", 0.0)`))
			Expect(codeStr).To(ContainSubstring(`response.get("boolVal", False)`))
		})
	})

	Describe("Integration", func() {
		It("should generate compilable code from parsed source", func() {
			// This is an integration test that verifies the full pipeline
			src := `package host

import "context"

// TestService is a test service.
//nd:hostservice name=Test permission=test
type TestService interface {
	// DoSomething does something.
	//nd:hostfunc
	DoSomething(ctx context.Context, input string) (output string, err error)
}
`
			// Create temporary directory
			tmpDir := GinkgoT().TempDir()
			path := tmpDir + "/test.go"
			err := writeFile(path, src)
			Expect(err).NotTo(HaveOccurred())

			// Parse
			services, err := ParseDirectory(tmpDir)
			Expect(err).NotTo(HaveOccurred())
			Expect(services).To(HaveLen(1))

			// Generate
			code, err := GenerateHost(services[0], "host")
			Expect(err).NotTo(HaveOccurred())

			// Format (validates syntax)
			formatted, err := format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			// Verify key elements
			codeStr := string(formatted)
			Expect(codeStr).To(ContainSubstring("RegisterTestHostFunctions"))
			Expect(codeStr).To(ContainSubstring(`"test_dosomething"`))
		})
	})
})

func writeFile(path, content string) error {
	return os.WriteFile(path, []byte(content), 0600)
}
