package internal

import (
	"go/format"
	"os"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Generator", func() {
	Describe("GenerateHost", func() {
		It("should generate valid Go code for a simple service with strings", func() {
			// String params/returns don't need JSON - they use direct memory read/write
			svc := Service{
				Name:       "SubsonicAPI",
				Permission: "subsonicapi",
				Interface:  "SubsonicAPIService",
				Methods: []Method{
					{
						Name:     "Call",
						HasError: true,
						Params:   []Param{NewParam("uri", "string")},
						Returns:  []Param{NewParam("response", "string")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			// Verify the code is valid Go
			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)

			// Check for generated header
			Expect(codeStr).To(ContainSubstring("Code generated by hostgen. DO NOT EDIT."))

			// Check for package declaration
			Expect(codeStr).To(ContainSubstring("package host"))

			// String params don't need request type - read directly from memory
			Expect(codeStr).NotTo(ContainSubstring("type SubsonicAPICallRequest struct"))

			// String return with error needs response type for error handling
			Expect(codeStr).To(ContainSubstring("type SubsonicAPICallResponse struct"))
			Expect(codeStr).To(ContainSubstring(`Response string `))
			Expect(codeStr).To(ContainSubstring(`Error string `))

			// Check for registration function
			Expect(codeStr).To(ContainSubstring("func RegisterSubsonicAPIHostFunctions(service SubsonicAPIService)"))

			// Check for host function name
			Expect(codeStr).To(ContainSubstring(`"subsonicapi_call"`))

			// Check for direct string read (not JSON unmarshal)
			Expect(codeStr).To(ContainSubstring("p.ReadString(stack[0])"))
		})

		It("should generate code for methods without parameters", func() {
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "NoParams",
						HasError: true,
						Returns:  []Param{NewParam("result", "string")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			// Should not have request type for methods without params
			Expect(codeStr).NotTo(ContainSubstring("type TestNoParamsRequest struct"))
		})

		It("should generate code for methods without return values", func() {
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "NoReturn",
						HasError: true,
						Params:   []Param{NewParam("input", "string")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should generate code for multiple methods", func() {
			svc := Service{
				Name:       "Scheduler",
				Permission: "scheduler",
				Interface:  "SchedulerService",
				Methods: []Method{
					{
						Name:     "ScheduleRecurring",
						HasError: true,
						Params:   []Param{NewParam("cronExpression", "string")},
						Returns:  []Param{NewParam("scheduleID", "string")},
					},
					{
						Name:     "ScheduleOneTime",
						HasError: true,
						Params:   []Param{NewParam("delaySeconds", "int32")},
						Returns:  []Param{NewParam("scheduleID", "string")},
					},
					{
						Name:     "CancelSchedule",
						HasError: true,
						Params:   []Param{NewParam("scheduleID", "string")},
						Returns:  []Param{NewParam("canceled", "bool")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			Expect(codeStr).To(ContainSubstring("scheduler_schedulerecurring"))
			Expect(codeStr).To(ContainSubstring("scheduler_scheduleonetime"))
			Expect(codeStr).To(ContainSubstring("scheduler_cancelschedule"))
		})

		It("should handle multiple simple parameters without JSON", func() {
			// All simple params (string, int32, bool) can be passed on stack directly
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "MultiParam",
						HasError: true,
						Params: []Param{
							NewParam("name", "string"),
							NewParam("count", "int32"),
							NewParam("enabled", "bool"),
						},
						Returns: []Param{NewParam("result", "string")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			// No request type for simple params - they're read directly from stack
			Expect(codeStr).NotTo(ContainSubstring("type TestMultiParamRequest struct"))
			// Check for direct stack reads
			Expect(codeStr).To(ContainSubstring("p.ReadString(stack[0])"))
			Expect(codeStr).To(ContainSubstring("extism.DecodeI32(stack[1])"))
			Expect(codeStr).To(ContainSubstring("extism.DecodeI32(stack[2])"))
			// Check that input ValueType slice has correct entries (3 params: PTR for string, I32 for int32, I32 for bool)
			Expect(codeStr).To(ContainSubstring("extism.ValueTypePTR, extism.ValueTypeI32, extism.ValueTypeI32"))
		})

		It("should use single PTR for mixed simple and complex params", func() {
			// When any param needs JSON, all are bundled into one request struct
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "MixedParam",
						HasError: true,
						Params: []Param{
							NewParam("id", "string"),     // simple (PTR for string)
							NewParam("tags", "[]string"), // complex - needs JSON
						},
						Returns: []Param{NewParam("count", "int32")}, // simple
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			_, err = format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			// Request type IS needed because of complex param
			Expect(codeStr).To(ContainSubstring("type TestMixedParamRequest struct"))
			// When using request type, only ONE PTR for input (the JSON request)
			Expect(codeStr).To(MatchRegexp(`\[\]extism\.ValueType\{extism\.ValueTypePTR\},\s*\[\]extism\.ValueType\{extism\.ValueTypePTR\}`))
		})

		It("should generate proper JSON tags for complex types", func() {
			// Complex types (structs, slices, maps) need JSON serialization
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "Method",
						HasError: true,
						Params:   []Param{NewParam("inputValue", "[]string")},           // slice needs JSON
						Returns:  []Param{NewParam("outputValue", "map[string]string")}, // map needs JSON
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			// Complex params need request type with JSON tags
			Expect(codeStr).To(ContainSubstring(`json:"inputValue"`))
			// Complex returns need response type with JSON tags
			Expect(codeStr).To(ContainSubstring(`json:"outputValue,omitempty"`))
		})

		It("should include required imports", func() {
			// Service with complex types needs JSON import
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:     "Method",
						HasError: true,
						Params:   []Param{NewParam("data", "MyStruct")}, // struct needs JSON
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			Expect(codeStr).To(ContainSubstring(`"context"`))
			Expect(codeStr).To(ContainSubstring(`"encoding/json"`))
			Expect(codeStr).To(ContainSubstring(`extism "github.com/extism/go-sdk"`))
		})

		It("should not include json import when not needed", func() {
			// Service with only simple types doesn't need JSON import
			svc := Service{
				Name:       "Test",
				Permission: "test",
				Interface:  "TestService",
				Methods: []Method{
					{
						Name:    "Method",
						Params:  []Param{NewParam("count", "int32")},
						Returns: []Param{NewParam("result", "int64")},
					},
				},
			}

			code, err := GenerateHost(svc, "host")
			Expect(err).NotTo(HaveOccurred())

			codeStr := string(code)
			Expect(codeStr).To(ContainSubstring(`"context"`))
			Expect(codeStr).NotTo(ContainSubstring(`"encoding/json"`))
			Expect(codeStr).To(ContainSubstring(`extism "github.com/extism/go-sdk"`))
		})
	})

	Describe("toJSONName", func() {
		It("should convert to camelCase", func() {
			Expect(toJSONName("InputValue")).To(Equal("inputValue"))
			Expect(toJSONName("URI")).To(Equal("uRI"))
			Expect(toJSONName("id")).To(Equal("id"))
		})

		It("should handle empty string", func() {
			Expect(toJSONName("")).To(Equal(""))
		})
	})

	Describe("NewParam", func() {
		It("should create param with auto-generated JSON name", func() {
			p := NewParam("MyParam", "string")
			Expect(p.Name).To(Equal("MyParam"))
			Expect(p.Type).To(Equal("string"))
			Expect(p.JSONName).To(Equal("myParam"))
		})
	})

	Describe("Integration", func() {
		It("should generate compilable code from parsed source", func() {
			// This is an integration test that verifies the full pipeline
			src := `package host

import "context"

// TestService is a test service.
//nd:hostservice name=Test permission=test
type TestService interface {
	// DoSomething does something.
	//nd:hostfunc
	DoSomething(ctx context.Context, input string) (output string, err error)
}
`
			// Create temporary directory
			tmpDir := GinkgoT().TempDir()
			path := tmpDir + "/test.go"
			err := writeFile(path, src)
			Expect(err).NotTo(HaveOccurred())

			// Parse
			services, err := ParseDirectory(tmpDir)
			Expect(err).NotTo(HaveOccurred())
			Expect(services).To(HaveLen(1))

			// Generate
			code, err := GenerateHost(services[0], "host")
			Expect(err).NotTo(HaveOccurred())

			// Format (validates syntax)
			formatted, err := format.Source(code)
			Expect(err).NotTo(HaveOccurred())

			// Verify key elements
			codeStr := string(formatted)
			Expect(codeStr).To(ContainSubstring("RegisterTestHostFunctions"))
			Expect(codeStr).To(ContainSubstring(`"test_dosomething"`))
		})
	})
})

func writeFile(path, content string) error {
	return os.WriteFile(path, []byte(content), 0600)
}
