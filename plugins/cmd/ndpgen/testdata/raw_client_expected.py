# Code generated by ndpgen. DO NOT EDIT.
#
# This file contains client wrappers for the Stream host service.
# It is intended for use in Navidrome plugins built with extism-py.
#
# IMPORTANT: Due to a limitation in extism-py, you cannot import this file directly.
# The @extism.import_fn decorators are only detected when defined in the plugin's
# main __init__.py file. Copy the needed functions from this file into your plugin.

from dataclasses import dataclass
from typing import Any, Tuple

import extism
import json
import struct


class HostFunctionError(Exception):
    """Raised when a host function returns an error."""
    pass


@extism.import_fn("extism:host/user", "stream_getstream")
def _stream_getstream(offset: int) -> int:
    """Raw host function - do not call directly."""
    ...


def stream_get_stream(uri: str) -> Tuple[str, bytes]:
    """GetStream returns raw binary stream data with content type.

    Args:
        uri: str parameter.

    Returns:
        Tuple of (content_type, data) with the raw binary response.

    Raises:
        HostFunctionError: If the host function returns an error.
    """
    request = {
        "uri": uri,
    }
    request_bytes = json.dumps(request).encode("utf-8")
    request_mem = extism.memory.alloc(request_bytes)
    response_offset = _stream_getstream(request_mem.offset)
    response_mem = extism.memory.find(response_offset)
    response_bytes = response_mem.bytes()

    if len(response_bytes) == 0:
        raise HostFunctionError("empty response from host")
    if response_bytes[0] == 0x01:
        raise HostFunctionError(response_bytes[1:].decode("utf-8"))
    if response_bytes[0] != 0x00:
        raise HostFunctionError("unknown response status")
    if len(response_bytes) < 5:
        raise HostFunctionError("malformed raw response: incomplete header")
    ct_len = struct.unpack(">I", response_bytes[1:5])[0]
    if len(response_bytes) < 5 + ct_len:
        raise HostFunctionError("malformed raw response: content-type overflow")
    content_type = response_bytes[5:5 + ct_len].decode("utf-8")
    data = response_bytes[5 + ct_len:]
    return content_type, data
