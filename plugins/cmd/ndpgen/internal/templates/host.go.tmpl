// Code generated by ndpgen. DO NOT EDIT.

package {{.Package}}

import (
	"context"
{{- if .Service.HasRawMethods}}
	"encoding/binary"
{{- end}}
	"encoding/json"

	extism "github.com/extism/go-sdk"
)

{{- /* Generate request/response types for all methods */ -}}
{{range .Service.Methods}}
{{- if .HasParams}}

// {{requestType .}} is the request type for {{$.Service.Name}}.{{.Name}}.
type {{requestType .}} struct {
{{- range .Params}}
	{{title .Name}} {{.Type}} `json:"{{.JSONName}}"`
{{- end}}
}
{{- end}}
{{- if not .Raw}}

// {{responseType .}} is the response type for {{$.Service.Name}}.{{.Name}}.
type {{responseType .}} struct {
{{- range .Returns}}
	{{title .Name}} {{.Type}} `json:"{{.JSONName}},omitempty"`
{{- end}}
{{- if .HasError}}
	Error string `json:"error,omitempty"`
{{- end}}
}
{{- end}}
{{end}}

// Register{{.Service.Name}}HostFunctions registers {{.Service.Name}} service host functions.
// The returned host functions should be added to the plugin's configuration.
func Register{{.Service.Name}}HostFunctions(service {{.Service.Interface}}) []extism.HostFunction {
	return []extism.HostFunction{
{{- range .Service.Methods}}
		new{{$.Service.Name}}{{.Name}}HostFunction(service),
{{- end}}
	}
}
{{range .Service.Methods}}

func new{{$.Service.Name}}{{.Name}}HostFunction(service {{$.Service.Interface}}) extism.HostFunction {
	return extism.NewHostFunctionWithStack(
		"{{exportName .}}",
		func(ctx context.Context, p *extism.CurrentPlugin, stack []uint64) {
{{- if .HasParams}}
			// Read JSON request from plugin memory
			reqBytes, err := p.ReadBytes(stack[0])
			if err != nil {
{{- if .Raw}}
				{{$.Service.Name | lower}}WriteRawError(p, stack, err)
{{- else}}
				{{$.Service.Name | lower}}WriteError(p, stack, err)
{{- end}}
				return
			}
			var req {{requestType .}}
			if err := json.Unmarshal(reqBytes, &req); err != nil {
{{- if .Raw}}
				{{$.Service.Name | lower}}WriteRawError(p, stack, err)
{{- else}}
				{{$.Service.Name | lower}}WriteError(p, stack, err)
{{- end}}
				return
			}
{{- end}}

			// Call the service method
{{- if .Raw}}
			{{range $i, $r := .Returns}}{{if $i}}, {{end}}{{lower $r.Name}}{{end}}, svcErr := service.{{.Name}}(ctx{{range .Params}}, req.{{title .Name}}{{end}})
			if svcErr != nil {
				{{$.Service.Name | lower}}WriteRawError(p, stack, svcErr)
				return
			}

			// Write binary-framed response to plugin memory:
			// [0x00][4-byte content-type length (big-endian)][content-type string][raw data]
			ctBytes := []byte({{lower (index .Returns 0).Name}})
			frame := make([]byte, 1+4+len(ctBytes)+len({{lower (index .Returns 1).Name}}))
			frame[0] = 0x00 // success
			binary.BigEndian.PutUint32(frame[1:5], uint32(len(ctBytes)))
			copy(frame[5:5+len(ctBytes)], ctBytes)
			copy(frame[5+len(ctBytes):], {{lower (index .Returns 1).Name}})

			respPtr, err := p.WriteBytes(frame)
			if err != nil {
				stack[0] = 0
				return
			}
			stack[0] = respPtr
{{- else if .HasReturns}}
{{- if .HasError}}
			{{range $i, $r := .Returns}}{{if $i}}, {{end}}{{lower $r.Name}}{{end}}, svcErr := service.{{.Name}}(ctx{{range .Params}}, req.{{title .Name}}{{end}})
			if svcErr != nil {
				{{$.Service.Name | lower}}WriteError(p, stack, svcErr)
				return
			}
{{- else}}
			{{range $i, $r := .Returns}}{{if $i}}, {{end}}{{lower $r.Name}}{{end}} := service.{{.Name}}(ctx{{range .Params}}, req.{{title .Name}}{{end}})
{{- end}}

			// Write JSON response to plugin memory
			resp := {{responseType .}}{
{{- range .Returns}}
				{{title .Name}}: {{lower .Name}},
{{- end}}
			}
			{{$.Service.Name | lower}}WriteResponse(p, stack, resp)
{{- else if .HasError}}
			if svcErr := service.{{.Name}}(ctx{{range .Params}}, req.{{title .Name}}{{end}}); svcErr != nil {
				{{$.Service.Name | lower}}WriteError(p, stack, svcErr)
				return
			}

			// Write JSON response to plugin memory
			resp := {{responseType .}}{}
			{{$.Service.Name | lower}}WriteResponse(p, stack, resp)
{{- else}}
			service.{{.Name}}(ctx{{range .Params}}, req.{{title .Name}}{{end}})

			// Write JSON response to plugin memory
			resp := {{responseType .}}{}
			{{$.Service.Name | lower}}WriteResponse(p, stack, resp)
{{- end}}
		},
		[]extism.ValueType{extism.ValueTypePTR},
		[]extism.ValueType{extism.ValueTypePTR},
	)
}
{{end}}

// {{.Service.Name | lower}}WriteResponse writes a JSON response to plugin memory.
func {{.Service.Name | lower}}WriteResponse(p *extism.CurrentPlugin, stack []uint64, resp any) {
	respBytes, err := json.Marshal(resp)
	if err != nil {
		{{.Service.Name | lower}}WriteError(p, stack, err)
		return
	}
	respPtr, err := p.WriteBytes(respBytes)
	if err != nil {
		stack[0] = 0
		return
	}
	stack[0] = respPtr
}

// {{.Service.Name | lower}}WriteError writes an error response to plugin memory.
func {{.Service.Name | lower}}WriteError(p *extism.CurrentPlugin, stack []uint64, err error) {
	errResp := struct {
		Error string `json:"error"`
	}{Error: err.Error()}
	respBytes, _ := json.Marshal(errResp)
	respPtr, _ := p.WriteBytes(respBytes)
	stack[0] = respPtr
}
{{- if .Service.HasRawMethods}}

// {{.Service.Name | lower}}WriteRawError writes a binary-framed error response to plugin memory.
// Format: [0x01][UTF-8 error message]
func {{.Service.Name | lower}}WriteRawError(p *extism.CurrentPlugin, stack []uint64, err error) {
	errMsg := []byte(err.Error())
	frame := make([]byte, 1+len(errMsg))
	frame[0] = 0x01 // error
	copy(frame[1:], errMsg)
	respPtr, _ := p.WriteBytes(frame)
	stack[0] = respPtr
}
{{- end}}
